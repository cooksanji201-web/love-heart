<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üíñ Magic Heart - Love Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a0a1a 50%, #0a0a0f 100%);
            font-family: 'Fira Code', monospace;
            cursor: none;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }

        /* Custom Cursor */
        #cursor {
            position: fixed;
            width: 30px;
            height: 30px;
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
        }

        #cursor::before {
            content: 'üíñ';
            font-size: 24px;
            animation: cursorPulse 0.5s infinite alternate;
        }

        @keyframes cursorPulse {
            from {
                transform: scale(1);
            }

            to {
                transform: scale(1.3);
            }
        }

        .trail {
            position: fixed;
            pointer-events: none;
            z-index: 9998;
            animation: trailFade 0.8s forwards;
        }

        @keyframes trailFade {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            100% {
                opacity: 0;
                transform: scale(0) rotate(360deg);
            }
        }

        /* Code rain */
        .code-rain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0.15;
            font-size: 12px;
            color: #ff69b4;
            overflow: hidden;
        }

        .code-column {
            position: absolute;
            top: -100%;
            animation: codefall linear infinite;
            white-space: nowrap;
        }

        @keyframes codefall {
            0% {
                transform: translateY(-100%);
            }

            100% {
                transform: translateY(200vh);
            }
        }

        /* UI */
        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            pointer-events: none;
            z-index: 100;
        }

        .guide {
            color: rgba(255, 105, 180, 0.9);
            font-size: 13px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff69b4;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 25px;
            border-radius: 15px;
            display: inline-block;
            border: 1px solid rgba(255, 105, 180, 0.3);
            backdrop-filter: blur(10px);
        }

        button {
            pointer-events: auto;
            cursor: pointer;
            background: linear-gradient(135deg, #ff1493, #c71585, #ff69b4);
            color: #FFF;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 15px 50px;
            border-radius: 30px;
            font-weight: 700;
            font-size: 16px;
            font-family: inherit;
            box-shadow: 0 0 30px rgba(255, 20, 147, 0.6);
            animation: pulse 1.5s infinite;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 50px rgba(255, 20, 147, 0.8);
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.03);
            }
        }

        /* Controls */
        #controls {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 100;
            display: none;
        }

        .control-btn {
            display: block;
            margin: 8px 0;
            padding: 12px 20px;
            border: 1px solid rgba(255, 105, 180, 0.4);
            border-radius: 10px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.3s;
            width: 160px;
            text-align: left;
            font-family: inherit;
            backdrop-filter: blur(10px);
            background: linear-gradient(135deg, rgba(255, 20, 147, 0.6), rgba(199, 21, 133, 0.6));
            color: white;
        }

        .control-btn:hover {
            transform: translateX(5px);
            box-shadow: 0 0 20px rgba(255, 105, 180, 0.5);
        }

        /* State indicator */
        #state-indicator {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #ff69b4;
            padding: 10px 25px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 100;
            display: none;
            border: 1px solid rgba(255, 105, 180, 0.3);
        }

        /* Flappy Game */
        #flappy-game {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 200;
            display: none;
        }

        #flappy-canvas {
            width: 100%;
            height: 100%;
        }

        #flappy-score {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            color: #ff69b4;
            text-shadow: 0 0 20px #ff1493, 2px 2px 0 #000;
            z-index: 201;
        }

        #flappy-instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff69b4;
            z-index: 201;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px 50px;
            border-radius: 20px;
            border: 2px solid #ff1493;
        }

        #flappy-instructions h2 {
            font-size: 32px;
            margin-bottom: 20px;
        }

        #flappy-instructions p {
            font-size: 16px;
            margin: 10px 0;
            opacity: 0.8;
        }

        #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff69b4;
            z-index: 201;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px 60px;
            border-radius: 20px;
            border: 2px solid #ff1493;
            display: none;
        }

        #game-over-screen h2 {
            font-size: 36px;
            color: #ff4500;
            margin-bottom: 20px;
        }

        #final-score {
            font-size: 48px;
            color: #ffd700;
            margin: 20px 0;
        }

        #high-score {
            font-size: 18px;
            color: #00ff7f;
            margin-bottom: 20px;
        }

        #back-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 202;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff69b4;
            color: #ff69b4;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
        }

        /* Floating hearts */
        .floating-heart {
            position: fixed;
            color: rgba(255, 105, 180, 0.6);
            font-size: 20px;
            animation: floatHeart linear infinite;
            pointer-events: none;
            z-index: 50;
        }

        @keyframes floatHeart {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }

            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }

        #copyright {
            position: absolute;
            bottom: 10px;
            right: 15px;
            color: rgba(255, 105, 180, 0.4);
            font-size: 11px;
            z-index: 100;
        }

        /* Loading screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0f, #1a0a1a, #0a0a0f);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 500;
        }

        .loading-heart {
            font-size: 80px;
            animation: loadingBeat 0.6s infinite alternate;
        }

        @keyframes loadingBeat {
            from {
                transform: scale(1);
            }

            to {
                transform: scale(1.3);
                filter: drop-shadow(0 0 30px #ff1493);
            }
        }

        .loading-text {
            color: #ff69b4;
            font-size: 18px;
            margin-top: 20px;
            animation: loadingDots 1.5s infinite;
        }

        @keyframes loadingDots {

            0%,
            20% {
                content: 'Loading';
            }

            40% {
                content: 'Loading.';
            }

            60% {
                content: 'Loading..';
            }

            80%,
            100% {
                content: 'Loading...';
            }
        }

        /* Rose falling */
        .falling-rose {
            position: fixed;
            pointer-events: none;
            z-index: 400;
            animation: roseFall linear forwards;
        }

        @keyframes roseFall {
            0% {
                transform: translateY(-50px) rotate(0deg) scale(0);
                opacity: 0;
            }

            10% {
                transform: translateY(0) rotate(20deg) scale(1);
                opacity: 1;
            }

            100% {
                transform: translateY(110vh) rotate(360deg) scale(0.8);
                opacity: 0.6;
            }
        }

        /* Leaderboard */
        #leaderboard {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ff1493;
            border-radius: 20px;
            padding: 25px;
            z-index: 300;
            min-width: 320px;
            display: none;
            box-shadow: 0 0 40px rgba(255, 20, 147, 0.5);
        }

        #leaderboard h3 {
            color: #ff69b4;
            text-align: center;
            margin-bottom: 15px;
            font-size: 22px;
        }

        #leaderboard-list {
            list-style: none;
            max-height: 300px;
            overflow-y: auto;
        }

        #leaderboard-list li {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 20, 147, 0.15);
            border-radius: 8px;
            color: #fff;
        }

        #leaderboard-list li:nth-child(1) {
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.3), rgba(255, 20, 147, 0.2));
        }

        #leaderboard-list li:nth-child(2) {
            background: linear-gradient(90deg, rgba(192, 192, 192, 0.3), rgba(255, 20, 147, 0.2));
        }

        #leaderboard-list li:nth-child(3) {
            background: linear-gradient(90deg, rgba(205, 127, 50, 0.3), rgba(255, 20, 147, 0.2));
        }

        .rank {
            color: #ffd700;
            font-weight: bold;
            width: 30px;
        }

        .player-name {
            flex: 1;
            color: #ff69b4;
        }

        .player-score {
            color: #00ff7f;
            font-weight: bold;
        }

        #close-leaderboard {
            display: block;
            margin: 15px auto 0;
            background: #ff1493;
            border: none;
            color: white;
            padding: 10px 30px;
            border-radius: 20px;
            cursor: pointer;
        }

        /* Name input modal */
        #name-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ff1493;
            border-radius: 20px;
            padding: 30px;
            z-index: 350;
            text-align: center;
            display: none;
            box-shadow: 0 0 40px rgba(255, 20, 147, 0.5);
        }

        #name-modal h3 {
            color: #ff69b4;
            margin-bottom: 20px;
        }

        #player-name-input {
            background: rgba(255, 20, 147, 0.2);
            border: 1px solid #ff69b4;
            color: white;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 16px;
            width: 200px;
            text-align: center;
            margin-bottom: 15px;
        }

        #submit-name {
            background: #ff1493;
            border: none;
            color: white;
            padding: 12px 30px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
        }

        /* Leaderboard button in game */
        #show-leaderboard-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff69b4;
            color: #ff69b4;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            z-index: 202;
        }
    </style>
</head>

<body>
    <div id="cursor"></div>
    <div class="code-rain" id="code-rain"></div>
    <div id="floating-hearts"></div>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-heart">üíñ</div>
        <div class="loading-text">Loading Love...</div>
    </div>

    <div id="controls">
        <button class="control-btn" onclick="setState('HEART')">üíñ 1. Heart</button>
        <button class="control-btn" onclick="setState('EXPLODE')">‚ú® 2. Explode</button>
        <button class="control-btn" onclick="setState('SPIRAL')">üåÄ 3. Spiral</button>
        <button class="control-btn" onclick="setState('CODE_HEART')">üíª 4. Code Heart</button>
        <button class="control-btn" onclick="setState('FLAPPY')">üéÆ 5. Flappy Heart</button>
    </div>

    <div id="state-indicator">Mode: <span id="current-state">HEART</span></div>

    <div id="ui-layer">
        <button id="btnStart" onclick="startSystem()">üíñ START LOVE üíñ</button>
    </div>

    <div id="copyright">üíñ Love Edition</div>
    <div id="canvas-container"></div>

    <!-- Flappy Game -->
    <div id="flappy-game">
        <button id="back-btn" onclick="exitFlappyGame()">‚Üê Quay l·∫°i</button>
        <button id="show-leaderboard-btn" onclick="showLeaderboard()">üèÜ B·∫£ng x·∫øp h·∫°ng</button>
        <div id="flappy-score">0</div>
        <canvas id="flappy-canvas"></canvas>
        <div id="flappy-instructions">
            <h2>üíñ Flappy Heart üíñ</h2>
            <p>Nh·∫•n <b>SPACE</b> ho·∫∑c <b>CLICK</b> ƒë·ªÉ bay</p>
            <p>Tr√°nh c√°c c·ªôt ƒë·ªÉ ghi ƒëi·ªÉm!</p>
            <p style="margin-top: 20px; color: #ffd700;">Nh·∫•n ƒë·ªÉ b·∫Øt ƒë·∫ßu...</p>
        </div>
        <div id="game-over-screen">
            <h2>üíî Game Over üíî</h2>
            <div id="final-score">0</div>
            <div id="high-score">High Score: 0</div>
            <button onclick="restartFlappyGame()">üîÑ Ch∆°i l·∫°i</button>
            <button onclick="showLeaderboard()" style="margin-top:10px; background:#8a2be2;">üèÜ Xem BXH</button>
        </div>
    </div>

    <!-- Name Input Modal -->
    <div id="name-modal">
        <h3>üéÆ Nh·∫≠p t√™n c·ªßa b·∫°n</h3>
        <input type="text" id="player-name-input" placeholder="T√™n..." maxlength="15">
        <br>
        <button id="submit-name" onclick="submitPlayerName()">üíñ X√°c nh·∫≠n</button>
    </div>

    <!-- Leaderboard -->
    <div id="leaderboard">
        <h3>üèÜ B·∫£ng X·∫øp H·∫°ng üèÜ</h3>
        <ul id="leaderboard-list"></ul>
        <button id="close-leaderboard" onclick="hideLeaderboard()">ƒê√≥ng</button>
    </div>

    <script>
        // Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyBxM1OGoEKGEjy923zb4xHJxsNDOcuG5xg",
            authDomain: "love-heart-game.firebaseapp.com",
            databaseURL: "https://love-heart-game-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "love-heart-game",
            storageBucket: "love-heart-game.firebasestorage.app",
            messagingSenderId: "355212210596",
            appId: "1:355212210596:web:098a00d66c184f7efe9131"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // Player name
        let playerName = localStorage.getItem('playerName') || '';

        function askPlayerName() {
            if (!playerName) {
                document.getElementById('name-modal').style.display = 'block';
            }
        }

        function submitPlayerName() {
            const name = document.getElementById('player-name-input').value.trim();
            if (name) {
                playerName = name;
                localStorage.setItem('playerName', name);
                document.getElementById('name-modal').style.display = 'none';
            }
        }

        // Leaderboard functions
        function saveScore(score) {
            if (!playerName || score <= 0) return;
            const scoreRef = database.ref('leaderboard').push();
            scoreRef.set({
                name: playerName,
                score: score,
                timestamp: Date.now()
            });
        }

        function showLeaderboard() {
            document.getElementById('leaderboard').style.display = 'block';
            loadLeaderboard();
        }

        function hideLeaderboard() {
            document.getElementById('leaderboard').style.display = 'none';
        }

        function loadLeaderboard() {
            const list = document.getElementById('leaderboard-list');
            list.innerHTML = '<li style="justify-content:center;color:#ff69b4;">ƒêang t·∫£i...</li>';

            database.ref('leaderboard').orderByChild('score').limitToLast(10).once('value', snapshot => {
                const scores = [];
                snapshot.forEach(child => {
                    scores.push(child.val());
                });
                scores.sort((a, b) => b.score - a.score);

                list.innerHTML = '';
                if (scores.length === 0) {
                    list.innerHTML = '<li style="justify-content:center;color:#888;">Ch∆∞a c√≥ ƒëi·ªÉm</li>';
                    return;
                }
                scores.forEach((item, i) => {
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="rank">#${i + 1}</span><span class="player-name">${item.name}</span><span class="player-score">${item.score}</span>`;
                    list.appendChild(li);
                });
            });
        }

        // Cursor
        document.addEventListener('mousemove', e => {
            document.getElementById('cursor').style.left = e.clientX + 'px';
            document.getElementById('cursor').style.top = e.clientY + 'px';
            mouseX = e.clientX / innerWidth;
            mouseY = e.clientY / innerHeight;
            if (Math.random() > 0.7) {
                const t = document.createElement('div');
                t.className = 'trail';
                t.textContent = ['üíñ', 'üíï', '‚ú®', 'üí´'][Math.floor(Math.random() * 4)];
                t.style.left = e.clientX + 'px';
                t.style.top = e.clientY + 'px';
                document.body.appendChild(t);
                setTimeout(() => t.remove(), 800);
            }
        });

        // Config
        const loader = new THREE.TextureLoader();
        const photoFiles = ['./image1.jpeg', './image2.jpeg', './image3.jpeg', './image4.jpeg', './image5.jpeg'];
        const photoTextures = photoFiles.map(f => loader.load(f));

        let scene, camera, renderer, groupMain, groupSecondary, groupHearts, photoMeshes = [], loveMesh, titleMesh;
        let state = 'HEART', mouseX = 0.5, mouseY = 0.5, tiltAngle = 0, targetTilt = 0, isDragging = false;
        const CONFIG = { particleCount1: 2500, particleCount2: 500, heartCount: 200, explodeRadius: 70, photoOrbitRadius: 25, spiralHeight: 80 };

        function createGlowTexture(c1, c2) {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createRadialGradient(64, 64, 0, 64, 64, 50);
            grd.addColorStop(0, '#fff'); grd.addColorStop(0.3, c1); grd.addColorStop(0.7, c2); grd.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grd; ctx.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function createHeartTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ff1493'; ctx.shadowColor = '#ff69b4'; ctx.shadowBlur = 10;
            ctx.beginPath(); ctx.moveTo(32, 20);
            ctx.bezierCurveTo(32, 16, 24, 8, 16, 16); ctx.bezierCurveTo(4, 24, 16, 40, 32, 52);
            ctx.bezierCurveTo(48, 40, 60, 24, 48, 16); ctx.bezierCurveTo(40, 8, 32, 16, 32, 20);
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        const textures = { glow1: createGlowTexture('#ff1493', '#ff69b4'), glow2: createGlowTexture('#8a2be2', '#9370db'), heart: createHeartTexture() };

        function createCodeRain() {
            const container = document.getElementById('code-rain');
            const snippets = ['love++', '‚ù§Ô∏è', 'if(love)', 'return you', 'while(true)', 'heart = full', 'you && me', 'forever()', 'üíï', 'üíñ'];
            for (let i = 0; i < 20; i++) {
                const col = document.createElement('div');
                col.className = 'code-column';
                col.style.left = (i * 5) + '%';
                col.style.animationDuration = (8 + Math.random() * 10) + 's';
                col.style.animationDelay = (Math.random() * 5) + 's';
                let text = '';
                for (let j = 0; j < 30; j++) text += snippets[Math.floor(Math.random() * snippets.length)] + '<br>';
                col.innerHTML = text;
                container.appendChild(col);
            }
        }

        function createFloatingHearts() {
            const container = document.getElementById('floating-hearts');
            setInterval(() => {
                const h = document.createElement('div');
                h.className = 'floating-heart';
                h.innerHTML = ['üíñ', 'üíó', 'üíï', '‚ù§Ô∏è', 'üíò'][Math.floor(Math.random() * 5)];
                h.style.left = Math.random() * 100 + '%';
                h.style.fontSize = (15 + Math.random() * 20) + 'px';
                h.style.animationDuration = (5 + Math.random() * 5) + 's';
                container.appendChild(h);
                setTimeout(() => h.remove(), 10000);
            }, 500);
        }

        function init3D() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a0f, 0.003);
            camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
            camera.position.z = 100;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            groupMain = createParticleSystem('glow1', CONFIG.particleCount1, 2.5);
            groupSecondary = createParticleSystem('glow2', CONFIG.particleCount2, 3.5);
            groupHearts = createParticleSystem('heart', CONFIG.heartCount, 4.0);
            createPhotos();
            createDecorations();
            animate();
        }

        function createParticleSystem(type, count, size) {
            const pPos = [], pHeart = [], pExplode = [], pSpiral = [], pCode = [], phases = [];
            for (let i = 0; i < count; i++) {
                const t = Math.random() * Math.PI * 2;
                let hx = 16 * Math.pow(Math.sin(t), 3);
                let hy = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                const r = Math.pow(Math.random(), 0.3);
                pHeart.push(hx * r * 2.5, hy * r * 2.5 + 5, (Math.random() - 0.5) * 10 * r);

                const u = Math.random(), v = Math.random();
                const phi = Math.acos(2 * v - 1), lam = 2 * Math.PI * u;
                const rad = CONFIG.explodeRadius * Math.cbrt(Math.random());
                pExplode.push(rad * Math.sin(phi) * Math.cos(lam), rad * Math.sin(phi) * Math.sin(lam), rad * Math.cos(phi));

                const sT = (i / count) * Math.PI * 8, sR = 20 + (i / count) * 30, sY = -CONFIG.spiralHeight / 2 + (i / count) * CONFIG.spiralHeight;
                pSpiral.push(Math.cos(sT) * sR, sY, Math.sin(sT) * sR);

                const eT = (i / count) * Math.PI * 2;
                let cx = 16 * Math.pow(Math.sin(eT), 3);
                let cy = 13 * Math.cos(eT) - 5 * Math.cos(2 * eT) - 2 * Math.cos(3 * eT) - Math.cos(4 * eT);
                const out = 0.85 + Math.random() * 0.15;
                pCode.push(cx * 4 * out, cy * 4 * out + 5, (Math.random() - 0.5) * 15);

                pPos.push(pHeart[i * 3], pHeart[i * 3 + 1], pHeart[i * 3 + 2]);
                phases.push(Math.random() * Math.PI * 2);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
            const colors = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) { colors[i * 3] = 1; colors[i * 3 + 1] = 0.4; colors[i * 3 + 2] = 0.7; }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.userData = { heart: pHeart, explode: pExplode, spiral: pSpiral, codeHeart: pCode, phases };
            const mat = new THREE.PointsMaterial({ size, map: textures[type], transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false });
            const pts = new THREE.Points(geo, mat);
            scene.add(pts);
            return pts;
        }

        function createPhotos() {
            const geo = new THREE.PlaneGeometry(8, 8);
            for (let i = 0; i < 5; i++) {
                const mat = new THREE.MeshBasicMaterial({ map: photoTextures[i], side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.visible = false;
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function createDecorations() {
            const c1 = document.createElement('canvas'); c1.width = 1024; c1.height = 256;
            const ctx1 = c1.getContext('2d');
            ctx1.font = 'bold 100px "Fira Code"'; ctx1.fillStyle = '#ff1493'; ctx1.textAlign = 'center';
            ctx1.shadowColor = '#ff69b4'; ctx1.shadowBlur = 40;
            ctx1.fillText("üíñ LOVE üíñ", 512, 140);
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c1), transparent: true, blending: THREE.AdditiveBlending }));
            titleMesh.position.set(0, 55, 0);
            scene.add(titleMesh);

            const c2 = document.createElement('canvas'); c2.width = 1024; c2.height = 256;
            const ctx2 = c2.getContext('2d');
            ctx2.font = 'bold 90px "Fira Code"'; ctx2.fillStyle = '#ff69b4'; ctx2.textAlign = 'center';
            ctx2.shadowColor = '#ff1493'; ctx2.shadowBlur = 30;
            ctx2.fillText("I LOVE YOU ‚ù§Ô∏è", 512, 140);
            loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c2), transparent: true, blending: THREE.AdditiveBlending }));
            loveMesh.position.set(0, 0, 20);
            scene.add(loveMesh);
        }

        function updateParticles(group, speed, rotY, time) {
            const pos = group.geometry.attributes.position.array;
            const col = group.geometry.attributes.color.array;
            const { phases } = group.geometry.userData;
            const key = state === 'SPIRAL' ? 'spiral' : state === 'CODE_HEART' ? 'codeHeart' : state === 'HEART' ? 'heart' : 'explode';
            const targets = group.geometry.userData[key];
            for (let i = 0; i < pos.length; i++) pos[i] += (targets[i] - pos[i]) * speed;
            group.geometry.attributes.position.needsUpdate = true;
            const count = pos.length / 3;
            if (state === 'HEART' || state === 'CODE_HEART') {
                group.rotation.y += (rotY - group.rotation.y) * 0.1;
                tiltAngle += (targetTilt - tiltAngle) * 0.1;
                group.rotation.x = tiltAngle * Math.PI / 180;
                const beat = 1 + Math.abs(Math.sin(time * 3)) * 0.15;
                group.scale.set(beat, beat, beat);
            } else if (state === 'SPIRAL') {
                group.rotation.y += 0.01;
                group.scale.set(1, 1, 1);
            } else {
                group.rotation.y += (rotY - group.rotation.y) * 0.1;
                group.scale.set(1, 1, 1);
            }
            for (let i = 0; i < count; i++) {
                const b = 0.7 + 0.5 * Math.sin(time * 5 + phases[i]);
                col[i * 3] = b; col[i * 3 + 1] = 0.4 * b; col[i * 3 + 2] = 0.7 * b;
            }
            group.geometry.attributes.color.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const rotY = (mouseX - 0.5) * 4;
            updateParticles(groupMain, 0.08, rotY, time);
            updateParticles(groupSecondary, 0.08, rotY, time);
            updateParticles(groupHearts, 0.08, rotY, time);

            if (state === 'HEART' || state === 'CODE_HEART') {
                titleMesh.visible = true; loveMesh.visible = true;
                const s = 1 + Math.abs(Math.sin(time * 3)) * 0.1;
                loveMesh.scale.set(s, s, 1);
                photoMeshes.forEach(m => m.visible = false);
            } else if (state === 'SPIRAL') {
                titleMesh.visible = false; loveMesh.visible = true;
                photoMeshes.forEach(m => m.visible = false);
            } else if (state === 'EXPLODE') {
                titleMesh.visible = false; loveMesh.visible = false;
                const baseAngle = groupMain.rotation.y;
                photoMeshes.forEach((mesh, i) => {
                    mesh.visible = true;
                    const angle = baseAngle + i * (Math.PI * 2 / 5);
                    mesh.position.lerp(new THREE.Vector3(Math.sin(angle) * CONFIG.photoOrbitRadius, Math.sin(time + i) * 3, Math.cos(angle) * CONFIG.photoOrbitRadius), 0.1);
                    mesh.lookAt(camera.position);
                });
            }
            renderer.render(scene, camera);
        }

        function setState(newState) {
            if (newState === 'FLAPPY') { startFlappyGame(); return; }
            state = newState;
            document.getElementById('current-state').textContent = newState;
            hideFlappyGame();
        }

        function startSystem() {
            // Show loading screen
            const loading = document.getElementById('loading-screen');
            loading.style.display = 'flex';
            document.getElementById('ui-layer').style.display = 'none';

            // Spawn falling roses like opening a book
            setTimeout(() => {
                for (let i = 0; i < 50; i++) {
                    setTimeout(() => {
                        const rose = document.createElement('div');
                        rose.className = 'falling-rose';
                        rose.textContent = ['üåπ', 'üå∏', 'üå∫', 'üíê', 'üå∑'][Math.floor(Math.random() * 5)];
                        rose.style.left = Math.random() * 100 + '%';
                        rose.style.top = '-50px';
                        rose.style.fontSize = (20 + Math.random() * 25) + 'px';
                        rose.style.animationDuration = (3 + Math.random() * 3) + 's';
                        document.body.appendChild(rose);
                        setTimeout(() => rose.remove(), 6000);
                    }, i * 60);
                }
            }, 500);

            // After loading, show main content
            setTimeout(() => {
                loading.style.display = 'none';
                document.getElementById('controls').style.display = 'block';
                document.getElementById('state-indicator').style.display = 'block';
                createCodeRain();
                createFloatingHearts();
                init3D();
            }, 2000);
        }

        document.addEventListener('keydown', e => {
            if (e.key === '1') setState('HEART');
            if (e.key === '2') setState('EXPLODE');
            if (e.key === '3') setState('SPIRAL');
            if (e.key === '4') setState('CODE_HEART');
            if (e.key === '5') setState('FLAPPY');
            if (e.key === ' ' && state === 'FLAPPY') flappyJump();
        });

        addEventListener('resize', () => {
            if (camera) { camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }
        });

        // FLAPPY GAME
        let flappyCanvas, flappyCtx, flappyBird = { x: 100, y: 300, velocity: 0, radius: 25 };
        let flappyPipes = [], flappyScore = 0, flappyHighScore = localStorage.getItem('flappyHS') || 0;
        let flappyRunning = false, flappyStarted = false, flappyAnimId = null;
        const GRAVITY = 0.35, JUMP = -8, PIPE_WIDTH = 70, PIPE_GAP = 220, PIPE_SPEED = 3;

        function initFlappyCanvas() {
            flappyCanvas = document.getElementById('flappy-canvas');
            flappyCtx = flappyCanvas.getContext('2d');
            flappyCanvas.width = innerWidth;
            flappyCanvas.height = innerHeight;
        }

        function startFlappyGame() {
            state = 'FLAPPY';
            document.getElementById('flappy-game').style.display = 'block';
            document.getElementById('flappy-instructions').style.display = 'block';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            initFlappyCanvas();
            resetFlappyGame();
            flappyGameLoop();
            // Ask for player name if not set
            askPlayerName();
        }

        function hideFlappyGame() {
            document.getElementById('flappy-game').style.display = 'none';
            if (flappyAnimId) cancelAnimationFrame(flappyAnimId);
            flappyRunning = false; flappyStarted = false;
            document.getElementById('controls').style.display = 'block';
        }

        function exitFlappyGame() { setState('HEART'); }

        function resetFlappyGame() {
            flappyBird = { x: 100, y: innerHeight / 2, velocity: 0, radius: 25 };
            flappyPipes = []; flappyScore = 0; flappyRunning = false; flappyStarted = false;
            bgScrollX = 0;
            initFlappyBackground();
            document.getElementById('flappy-score').textContent = '0';
            document.getElementById('high-score').textContent = 'High Score: ' + flappyHighScore;
        }

        // Background elements
        let bgScrollX = 0;
        let buildings = [], stars = [], clouds = [], floatingObjs = [];

        function initFlappyBackground() {
            // Buildings - 3 layers parallax
            buildings = [];
            for (let layer = 0; layer < 3; layer++) {
                const count = 8 + layer * 3;
                for (let i = 0; i < count; i++) {
                    buildings.push({
                        x: i * (innerWidth / count) * 1.5 + Math.random() * 50,
                        width: 40 + Math.random() * 60 + layer * 20,
                        height: 80 + Math.random() * 150 + layer * 50,
                        layer: layer,
                        windows: Math.floor(3 + Math.random() * 6),
                        color: layer === 0 ? '#1a0025' : layer === 1 ? '#2a0040' : '#3a0055'
                    });
                }
            }
            // Stars
            stars = [];
            for (let i = 0; i < 80; i++) {
                stars.push({ x: Math.random() * innerWidth, y: Math.random() * innerHeight * 0.6, size: 0.5 + Math.random() * 2, twinkle: Math.random() * Math.PI * 2 });
            }
            // Clouds
            clouds = [];
            for (let i = 0; i < 6; i++) {
                clouds.push({ x: Math.random() * innerWidth * 1.5, y: 50 + Math.random() * 150, size: 30 + Math.random() * 50, speed: 0.3 + Math.random() * 0.5 });
            }
            // Floating objects (hearts, stars, roses, moons)
            floatingObjs = [];
            const objTypes = ['üíñ', '‚≠ê', 'üåπ', 'üåô', 'üíï', '‚ú®', 'ü¶ã', 'üí´'];
            for (let i = 0; i < 15; i++) {
                floatingObjs.push({
                    x: Math.random() * innerWidth * 2,
                    y: 100 + Math.random() * (innerHeight - 300),
                    type: objTypes[Math.floor(Math.random() * objTypes.length)],
                    size: 15 + Math.random() * 20,
                    speed: 1 + Math.random() * 2,
                    wobble: Math.random() * Math.PI * 2
                });
            }
        }

        function restartFlappyGame() {
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('flappy-instructions').style.display = 'block';
            resetFlappyGame();
        }

        function flappyJump() {
            if (!flappyStarted) { flappyStarted = true; flappyRunning = true; document.getElementById('flappy-instructions').style.display = 'none'; }
            if (flappyRunning) flappyBird.velocity = JUMP;
        }

        document.getElementById('flappy-game').onclick = e => { if (e.target.tagName !== 'BUTTON') flappyJump(); };

        function createPipe() {
            const topH = 60 + Math.random() * (innerHeight - PIPE_GAP - 120);
            flappyPipes.push({ x: innerWidth, topHeight: topH, bottomY: topH + PIPE_GAP, passed: false });
        }

        function updateFlappy() {
            if (!flappyRunning) return;
            flappyBird.velocity += GRAVITY;
            flappyBird.y += flappyBird.velocity;
            bgScrollX += 2;
            if (flappyPipes.length === 0 || flappyPipes[flappyPipes.length - 1].x < innerWidth - 350) createPipe();
            for (let i = flappyPipes.length - 1; i >= 0; i--) {
                flappyPipes[i].x -= PIPE_SPEED;
                if (!flappyPipes[i].passed && flappyPipes[i].x + PIPE_WIDTH < flappyBird.x) {
                    flappyPipes[i].passed = true;
                    flappyScore++;
                    document.getElementById('flappy-score').textContent = flappyScore;
                }
                if (flappyPipes[i].x < -PIPE_WIDTH) flappyPipes.splice(i, 1);
            }
            checkCollision();
        }

        function checkCollision() {
            if (flappyBird.y - flappyBird.radius < 0 || flappyBird.y + flappyBird.radius > innerHeight) { gameOver(); return; }
            for (let p of flappyPipes) {
                if (flappyBird.x + flappyBird.radius > p.x && flappyBird.x - flappyBird.radius < p.x + PIPE_WIDTH) {
                    if (flappyBird.y - flappyBird.radius < p.topHeight || flappyBird.y + flappyBird.radius > p.bottomY) { gameOver(); return; }
                }
            }
        }

        function gameOver() {
            flappyRunning = false;
            if (flappyScore > flappyHighScore) { flappyHighScore = flappyScore; localStorage.setItem('flappyHS', flappyHighScore); }
            document.getElementById('final-score').textContent = flappyScore;
            document.getElementById('high-score').textContent = 'High Score: ' + flappyHighScore;
            document.getElementById('game-over-screen').style.display = 'block';
            // Save score to Firebase
            saveScore(flappyScore);
        }

        function drawFlappy() {
            const ctx = flappyCtx, w = flappyCanvas.width, h = flappyCanvas.height;
            ctx.clearRect(0, 0, w, h);

            // Sky gradient
            const sky = ctx.createLinearGradient(0, 0, 0, h);
            sky.addColorStop(0, '#0a0018'); sky.addColorStop(0.4, '#1a0035'); sky.addColorStop(0.7, '#2d0050'); sky.addColorStop(1, '#3a0060');
            ctx.fillStyle = sky;
            ctx.fillRect(0, 0, w, h);

            // Stars with twinkle
            const time = Date.now() / 1000;
            stars.forEach(s => {
                const brightness = 0.5 + Math.sin(time * 3 + s.twinkle) * 0.5;
                ctx.beginPath();
                ctx.arc((s.x - bgScrollX * 0.05) % (w + 50), s.y, s.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 200, 220, ${brightness})`;
                ctx.fill();
            });

            // Clouds
            clouds.forEach(c => {
                const cx = ((c.x - bgScrollX * c.speed * 0.3) % (w + 200) + w + 200) % (w + 200) - 100;
                ctx.beginPath();
                ctx.arc(cx, c.y, c.size, 0, Math.PI * 2);
                ctx.arc(cx + c.size * 0.6, c.y - c.size * 0.2, c.size * 0.7, 0, Math.PI * 2);
                ctx.arc(cx - c.size * 0.5, c.y + c.size * 0.1, c.size * 0.6, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(80, 40, 100, 0.3)';
                ctx.fill();
            });

            // Buildings (3 layers parallax)
            for (let layer = 0; layer < 3; layer++) {
                const speedMult = 0.2 + layer * 0.3;
                buildings.filter(b => b.layer === layer).forEach(b => {
                    const bx = ((b.x - bgScrollX * speedMult) % (w * 1.5) + w * 1.5) % (w * 1.5) - w * 0.25;
                    const by = h - b.height;

                    // Building body
                    ctx.fillStyle = b.color;
                    ctx.fillRect(bx, by, b.width, b.height);

                    // Building outline glow
                    ctx.strokeStyle = `rgba(255, 105, 180, ${0.1 + layer * 0.1})`;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(bx, by, b.width, b.height);

                    // Windows
                    const winW = 6, winH = 10, winGap = 18;
                    for (let row = 0; row < Math.min(b.windows, Math.floor((b.height - 20) / winGap)); row++) {
                        for (let col = 0; col < 3; col++) {
                            const wx = bx + 8 + col * (b.width - 20) / 3;
                            const wy = by + 12 + row * winGap;
                            const lit = Math.sin(b.x + row * 5 + col * 7 + time) > 0.3;
                            ctx.fillStyle = lit ? `rgba(255, 200, 100, ${0.4 + layer * 0.2})` : 'rgba(20, 10, 30, 0.8)';
                            ctx.fillRect(wx, wy, winW, winH);
                        }
                    }

                    // Rooftop antenna for tall buildings
                    if (b.height > 180) {
                        ctx.strokeStyle = 'rgba(255, 105, 180, 0.4)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(bx + b.width / 2, by);
                        ctx.lineTo(bx + b.width / 2, by - 15);
                        ctx.stroke();
                        if (Math.sin(time * 4) > 0) {
                            ctx.beginPath();
                            ctx.arc(bx + b.width / 2, by - 15, 3, 0, Math.PI * 2);
                            ctx.fillStyle = '#ff1493';
                            ctx.fill();
                        }
                    }
                });
            }

            // Floating objects
            floatingObjs.forEach(obj => {
                const ox = ((obj.x - bgScrollX * obj.speed * 0.5) % (w + 200) + w + 200) % (w + 200) - 100;
                const oy = obj.y + Math.sin(time * 2 + obj.wobble) * 15;
                ctx.font = obj.size + 'px serif';
                ctx.fillText(obj.type, ox, oy);
            });

            // Pipes
            flappyPipes.forEach(p => {
                const pGrad = ctx.createLinearGradient(p.x, 0, p.x + PIPE_WIDTH, 0);
                pGrad.addColorStop(0, '#8b008b'); pGrad.addColorStop(0.5, '#4b0082'); pGrad.addColorStop(1, '#8b008b');
                ctx.fillStyle = pGrad;
                ctx.fillRect(p.x, 0, PIPE_WIDTH, p.topHeight);
                ctx.fillRect(p.x, p.bottomY, PIPE_WIDTH, h - p.bottomY);
                ctx.strokeStyle = '#ff69b4'; ctx.lineWidth = 3;
                ctx.strokeRect(p.x, 0, PIPE_WIDTH, p.topHeight);
                ctx.strokeRect(p.x, p.bottomY, PIPE_WIDTH, h - p.bottomY);
                // Pipe caps
                ctx.fillStyle = '#9932cc';
                ctx.fillRect(p.x - 5, p.topHeight - 15, PIPE_WIDTH + 10, 15);
                ctx.fillRect(p.x - 5, p.bottomY, PIPE_WIDTH + 10, 15);
            });

            // HEART WITH CUTE SMALL WINGS
            const x = flappyBird.x, y = flappyBird.y, s = flappyBird.radius * 1.2;
            const rot = Math.max(-0.4, Math.min(0.4, flappyBird.velocity * 0.04));
            const wingFlap = Math.sin(time * 20) * 0.3;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rot);

            // Trail particles (smaller)
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.arc(-12 - i * 8, Math.sin(time * 12 + i) * 3, (4 - i) * 1.5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 182, 193, ${(4 - i) / 10})`;
                ctx.fill();
            }

            // Left wing (smaller, cuter)
            ctx.save();
            ctx.rotate(wingFlap * 0.8);
            ctx.beginPath();
            ctx.moveTo(-s * 0.35, -s * 0.1);
            ctx.quadraticCurveTo(-s * 0.7, -s * 0.5, -s * 0.9, -s * 0.15);
            ctx.quadraticCurveTo(-s * 0.75, s * 0.1, -s * 0.35, s * 0.05);
            ctx.closePath();
            const wingGrad = ctx.createLinearGradient(-s * 0.9, 0, -s * 0.3, 0);
            wingGrad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            wingGrad.addColorStop(0.5, 'rgba(255, 182, 193, 0.8)');
            wingGrad.addColorStop(1, 'rgba(255, 105, 180, 0.5)');
            ctx.fillStyle = wingGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,182,193,0.6)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();

            // Right wing (smaller, cuter)
            ctx.save();
            ctx.rotate(-wingFlap * 0.8);
            ctx.beginPath();
            ctx.moveTo(s * 0.35, -s * 0.1);
            ctx.quadraticCurveTo(s * 0.7, -s * 0.5, s * 0.9, -s * 0.15);
            ctx.quadraticCurveTo(s * 0.75, s * 0.1, s * 0.35, s * 0.05);
            ctx.closePath();
            ctx.fillStyle = wingGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,182,193,0.6)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();

            // Heart body
            ctx.shadowColor = '#ff1493';
            ctx.shadowBlur = 25;
            ctx.beginPath();
            ctx.moveTo(0, -s * 0.25);
            ctx.bezierCurveTo(-s * 0.5, -s * 0.8, -s, -s * 0.25, 0, s * 0.6);
            ctx.bezierCurveTo(s, -s * 0.25, s * 0.5, -s * 0.8, 0, -s * 0.25);
            const hGrad = ctx.createRadialGradient(0, -s * 0.2, 0, 0, 0, s);
            hGrad.addColorStop(0, '#fff0f5'); hGrad.addColorStop(0.3, '#ffb6c1'); hGrad.addColorStop(0.6, '#ff69b4'); hGrad.addColorStop(1, '#c71585');
            ctx.fillStyle = hGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(199, 21, 133, 0.6)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Shine
            ctx.beginPath();
            ctx.arc(-s * 0.25, -s * 0.35, s * 0.12, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-s * 0.1, -s * 0.2, s * 0.06, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();

            ctx.restore();
        }

        function flappyGameLoop() {
            if (state !== 'FLAPPY') return;
            updateFlappy();
            drawFlappy();
            flappyAnimId = requestAnimationFrame(flappyGameLoop);
        }
    </script>
</body>

</html>
