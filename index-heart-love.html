<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üíñ Magic Heart - Love Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Three.js Post-processing -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <!-- GSAP for smooth animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a0a1a 50%, #0a0a0f 100%);
            font-family: 'Poppins', 'Fira Code', monospace;
            cursor: none;
            color: #fff;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }

        /* Custom Cursor */
        #cursor {
            position: fixed;
            width: 30px;
            height: 30px;
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
        }

        #cursor::before {
            content: 'üíñ';
            font-size: 24px;
            animation: cursorPulse 0.5s infinite alternate;
        }

        @keyframes cursorPulse {
            from {
                transform: scale(1);
            }

            to {
                transform: scale(1.3);
            }
        }

        .trail {
            position: fixed;
            pointer-events: none;
            z-index: 9998;
            animation: trailFade 0.8s forwards;
        }

        @keyframes trailFade {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            100% {
                opacity: 0;
                transform: scale(0) rotate(360deg);
            }
        }

        /* Code rain */
        .code-rain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0.15;
            font-size: 12px;
            color: #ff69b4;
            overflow: hidden;
        }

        .code-column {
            position: absolute;
            top: -100%;
            animation: codefall linear infinite;
            white-space: nowrap;
        }

        @keyframes codefall {
            0% {
                transform: translateY(-100%);
            }

            100% {
                transform: translateY(200vh);
            }
        }

        /* UI */
        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            pointer-events: none;
            z-index: 100;
        }

        .guide {
            color: rgba(255, 105, 180, 0.9);
            font-size: 13px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff69b4;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 25px;
            border-radius: 15px;
            display: inline-block;
            border: 1px solid rgba(255, 105, 180, 0.3);
            backdrop-filter: blur(10px);
        }

        button {
            pointer-events: auto;
            cursor: pointer;
            background: linear-gradient(145deg, rgba(255, 80, 180, 0.25), rgba(180, 40, 140, 0.35));
            color: #fff;
            border: 1px solid rgba(255, 150, 200, 0.3);
            padding: 14px 32px;
            border-radius: 16px;
            font-weight: 600;
            font-size: 15px;
            font-family: inherit;
            box-shadow:
                0 4px 15px rgba(255, 20, 147, 0.3),
                0 8px 30px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow:
                0 8px 25px rgba(255, 20, 147, 0.4),
                0 15px 40px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 200, 230, 0.5);
        }

        button:active {
            transform: translateY(-1px) scale(0.98);
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.03);
            }
        }

        /* Controls Panel - 3D Glass Card */
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: none;
            background: linear-gradient(145deg, rgba(40, 20, 60, 0.9), rgba(25, 12, 40, 0.95));
            padding: 16px;
            border-radius: 20px;
            border: 1px solid rgba(255, 100, 180, 0.25);
            box-shadow:
                0 10px 40px rgba(0, 0, 0, 0.6),
                0 0 60px rgba(255, 20, 147, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
        }

        .control-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 6px 0;
            padding: 12px 18px;
            border: 1px solid rgba(255, 150, 200, 0.15);
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            width: 175px;
            text-align: left;
            font-family: inherit;
            backdrop-filter: blur(8px);
            background: linear-gradient(135deg, rgba(255, 80, 180, 0.12), rgba(180, 40, 140, 0.08));
            color: #ffd0e8;
            box-shadow:
                0 3px 10px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .control-btn::after {
            content: '‚Üí';
            position: absolute;
            right: 15px;
            opacity: 0;
            transform: translateX(-10px);
            transition: all 0.2s ease;
            color: #ff69b4;
        }

        .control-btn:hover {
            transform: translateX(5px);
            background: linear-gradient(135deg, rgba(255, 100, 200, 0.25), rgba(200, 60, 160, 0.2));
            border-color: rgba(255, 180, 220, 0.3);
            box-shadow:
                0 6px 20px rgba(255, 20, 147, 0.2),
                0 10px 30px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .control-btn:hover::after {
            opacity: 1;
            transform: translateX(0);
        }

        .control-btn:active {
            transform: translateX(3px) scale(0.98);
        }

        /* State indicator */
        #state-indicator {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #ff69b4;
            padding: 10px 25px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 100;
            display: none;
            border: 1px solid rgba(255, 105, 180, 0.3);
        }

        /* Flappy Game */
        #flappy-game {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 200;
            display: none;
        }

        #flappy-canvas {
            width: 100%;
            height: 100%;
        }

        #flappy-score {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            color: #ff69b4;
            text-shadow: 0 0 20px #ff1493, 2px 2px 0 #000;
            z-index: 201;
        }

        #flappy-instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff69b4;
            z-index: 201;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px 50px;
            border-radius: 20px;
            border: 2px solid #ff1493;
        }

        #flappy-instructions h2 {
            font-size: 32px;
            margin-bottom: 20px;
        }

        #flappy-instructions p {
            font-size: 16px;
            margin: 10px 0;
            opacity: 0.8;
        }

        #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff69b4;
            z-index: 201;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px 60px;
            border-radius: 20px;
            border: 2px solid #ff1493;
            display: none;
        }

        #game-over-screen h2 {
            font-size: 36px;
            color: #ff4500;
            margin-bottom: 20px;
        }

        #final-score {
            font-size: 48px;
            color: #ffd700;
            margin: 20px 0;
        }

        #high-score {
            font-size: 18px;
            color: #00ff7f;
            margin-bottom: 20px;
        }

        #back-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 202;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff69b4;
            color: #ff69b4;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
        }

        /* Floating hearts */
        .floating-heart {
            position: fixed;
            color: rgba(255, 105, 180, 0.6);
            font-size: 20px;
            animation: floatHeart linear infinite;
            pointer-events: none;
            z-index: 50;
        }

        @keyframes floatHeart {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }

            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }

        #copyright {
            position: absolute;
            bottom: 10px;
            right: 15px;
            color: rgba(255, 105, 180, 0.4);
            font-size: 11px;
            z-index: 100;
        }

        /* Loading screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0f, #1a0a1a, #0a0a0f);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 500;
        }

        .loading-heart {
            font-size: 80px;
            animation: loadingBeat 0.6s infinite alternate;
        }

        @keyframes loadingBeat {
            from {
                transform: scale(1);
            }

            to {
                transform: scale(1.3);
                filter: drop-shadow(0 0 30px #ff1493);
            }
        }

        .loading-text {
            color: #ff69b4;
            font-size: 18px;
            margin-top: 20px;
            animation: loadingDots 1.5s infinite;
        }

        @keyframes loadingDots {

            0%,
            20% {
                content: 'Loading';
            }

            40% {
                content: 'Loading.';
            }

            60% {
                content: 'Loading..';
            }

            80%,
            100% {
                content: 'Loading...';
            }
        }

        /* Rose falling */
        .falling-rose {
            position: fixed;
            pointer-events: none;
            z-index: 400;
            animation: roseFall linear forwards;
        }

        @keyframes roseFall {
            0% {
                transform: translateY(-50px) rotate(0deg) scale(0);
                opacity: 0;
            }

            10% {
                transform: translateY(0) rotate(20deg) scale(1);
                opacity: 1;
            }

            100% {
                transform: translateY(110vh) rotate(360deg) scale(0.8);
                opacity: 0.6;
            }
        }

        /* Leaderboard - Professional Design */
        #leaderboard {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: linear-gradient(135deg, rgba(20, 0, 30, 0.98), rgba(40, 0, 60, 0.95));
            border: 2px solid transparent;
            border-image: linear-gradient(135deg, #ff1493, #8a2be2, #ff69b4) 1;
            border-radius: 25px;
            padding: 30px;
            z-index: 300;
            min-width: 380px;
            max-width: 90vw;
            display: none;
            box-shadow: 0 0 60px rgba(255, 20, 147, 0.4), inset 0 0 30px rgba(255, 105, 180, 0.1);
            backdrop-filter: blur(20px);
            animation: modalPop 0.4s ease forwards;
        }

        @keyframes modalPop {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        #leaderboard h3 {
            color: transparent;
            background: linear-gradient(90deg, #ffd700, #ff69b4, #ffd700);
            background-clip: text;
            -webkit-background-clip: text;
            text-align: center;
            margin-bottom: 20px;
            font-size: 30px;
            text-shadow: 0 0 28px rgba(255, 215, 0, 0.45);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {

            0%,
            100% {
                filter: brightness(1);
            }

            50% {
                filter: brightness(1.3);
            }
        }

        #leaderboard-list {
            list-style: none;
            max-height: 350px;
            overflow-y: auto;
            padding-right: 5px;
        }

        #leaderboard-list::-webkit-scrollbar {
            width: 6px;
        }

        #leaderboard-list::-webkit-scrollbar-track {
            background: rgba(255, 105, 180, 0.1);
            border-radius: 3px;
        }

        #leaderboard-list::-webkit-scrollbar-thumb {
            background: linear-gradient(#ff1493, #8a2be2);
            border-radius: 3px;
        }

        #leaderboard-list li {
            display: flex;
            align-items: center;
            padding: 14px 18px;
            margin: 10px 0;
            background: rgba(255, 20, 147, 0.06);
            border-radius: 14px;
            color: #fff;
            transition: all 0.24s ease;
            border: 1px solid rgba(255, 105, 180, 0.12);
            font-size: 15px;
        }

        #leaderboard-list li:hover {
            transform: translateX(5px);
            background: rgba(255, 20, 147, 0.2);
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.3);
        }

        #leaderboard-list li:nth-child(1) {
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.25), rgba(255, 20, 147, 0.15));
            border: 1px solid rgba(255, 215, 0, 0.4);
            animation: goldGlow 2s infinite;
        }

        @keyframes goldGlow {

            0%,
            100% {
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            }

            50% {
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.5);
            }
        }

        #leaderboard-list li:nth-child(2) {
            background: linear-gradient(90deg, rgba(192, 192, 192, 0.25), rgba(255, 20, 147, 0.15));
            border: 1px solid rgba(192, 192, 192, 0.3);
        }

        #leaderboard-list li:nth-child(3) {
            background: linear-gradient(90deg, rgba(205, 127, 50, 0.25), rgba(255, 20, 147, 0.15));
            border: 1px solid rgba(205, 127, 50, 0.3);
        }

        .rank {
            font-size: 20px;
            width: 40px;
            text-align: center;
        }

        .player-name {
            flex: 1;
            color: #ff69b4;
            font-weight: 500;
            margin-left: 10px;
        }

        .player-score {
            color: #00ff7f;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(0, 255, 127, 0.5);
        }

        #close-leaderboard {
            display: block;
            margin: 20px auto 0;
            background: linear-gradient(135deg, #ff1493, #8a2be2);
            border: none;
            color: white;
            padding: 12px 40px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 15px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(255, 20, 147, 0.4);
        }

        #close-leaderboard:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(255, 20, 147, 0.6);
        }

        /* Name input modal - Professional Design */
        #name-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(20, 0, 30, 0.98), rgba(40, 0, 60, 0.95));
            border: 2px solid transparent;
            border-image: linear-gradient(135deg, #ff1493, #8a2be2) 1;
            border-radius: 25px;
            padding: 40px 50px;
            z-index: 350;
            text-align: center;
            display: none;
            box-shadow: 0 0 80px rgba(255, 20, 147, 0.5), inset 0 0 40px rgba(255, 105, 180, 0.1);
            backdrop-filter: blur(20px);
            animation: modalPop 0.4s ease forwards;
        }

        #name-modal h3 {
            color: #ff69b4;
            margin-bottom: 10px;
            font-size: 26px;
        }

        #name-modal p {
            color: rgba(255, 105, 180, 0.7);
            margin-bottom: 25px;
            font-size: 14px;
        }

        .avatar-select {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .avatar-option {
            font-size: 32px;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .avatar-option:hover,
        .avatar-option.selected {
            background: rgba(255, 20, 147, 0.3);
            border-color: #ff1493;
            transform: scale(1.2);
        }

        #player-name-input {
            background: rgba(255, 20, 147, 0.15);
            border: 2px solid rgba(255, 105, 180, 0.4);
            color: white;
            padding: 15px 25px;
            border-radius: 15px;
            font-size: 18px;
            width: 250px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        #player-name-input:focus {
            outline: none;
            border-color: #ff1493;
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.4);
        }

        #player-name-input::placeholder {
            color: rgba(255, 105, 180, 0.5);
        }

        #submit-name {
            background: linear-gradient(135deg, #ff1493, #c71585);
            border: none;
            color: white;
            padding: 15px 50px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 5px 25px rgba(255, 20, 147, 0.5);
            font-family: inherit;
        }

        #submit-name:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 35px rgba(255, 20, 147, 0.7);
        }

        /* Game UI buttons */
        #show-leaderboard-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.8), rgba(255, 20, 147, 0.8));
            border: 1px solid rgba(255, 105, 180, 0.5);
            color: white;
            padding: 12px 20px;
            border-radius: 15px;
            cursor: pointer;
            z-index: 202;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 20, 147, 0.3);
        }

        #show-leaderboard-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 25px rgba(255, 20, 147, 0.5);
        }

        /* Level indicator */
        #level-indicator {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 20, 147, 0.2));
            border: 1px solid rgba(255, 215, 0, 0.5);
            color: #ffd700;
            padding: 10px 25px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            z-index: 202;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        /* Game buttons - Professional styling */
        #show-leaderboard-btn,
        #change-name-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 202;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.9), rgba(75, 0, 130, 0.9));
            border: 2px solid rgba(255, 105, 180, 0.6);
            color: white;
            padding: 12px 20px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
            backdrop-filter: blur(5px);
        }

        #show-leaderboard-btn {
            right: 80px;
        }

        #change-name-btn {
            top: 15px;
            right: 15px;
            padding: 12px 15px;
        }

        #show-leaderboard-btn:hover,
        #change-name-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 6px 25px rgba(255, 20, 147, 0.5);
            border-color: #ff1493;
        }

        /* Player info bar - moved down to avoid overlap */
        #player-info-bar {
            position: absolute;
            top: 60px;
            left: 15px;
            display: flex;
            gap: 10px;
            z-index: 202;
        }

        #player-info-bar>div {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(40, 0, 60, 0.9));
            padding: 10px 18px;
            border-radius: 15px;
            color: #ff69b4;
            font-size: 13px;
            font-weight: 600;
            border: 2px solid rgba(255, 105, 180, 0.5);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6), inset 0 0 15px rgba(255, 105, 180, 0.1);
        }

        #player-lives-display {
            color: #ff1493;
        }

        #player-best-display {
            color: #ffd700;
        }

        /* Active effects display */
        #active-effects {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 202;
        }

        .effect-badge {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            animation: effectPulse 1s infinite;
        }

        @keyframes effectPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        /* Level up notification - top bar style */
        #level-up-toast {
            position: fixed;
            top: -60px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            color: white;
            padding: 12px 40px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            z-index: 500;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            box-shadow: 0 4px 20px rgba(255, 20, 147, 0.5);
            transition: top 0.3s ease;
        }

        #level-up-toast.show {
            top: 80px;
        }

        /* Level transition overlay */
        #level-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 600;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.28s ease;
            backdrop-filter: blur(6px);
        }

        #level-transition.show {
            opacity: 1;
            pointer-events: auto;
        }

        .lt-box {
            background: linear-gradient(135deg, rgba(20, 10, 30, 0.95), rgba(40, 0, 60, 0.95));
            padding: 28px 36px;
            border-radius: 16px;
            display: flex;
            gap: 18px;
            align-items: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), inset 0 0 24px rgba(255, 20, 147, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.04);
        }

        .lt-icon {
            font-size: 44px;
        }

        .lt-text {
            color: #ffd7f0;
            font-size: 20px;
            font-weight: 700;
        }

        /* Blur state applied during level transition */
        #flappy-game.blurred,
        #canvas-container.blurred {
            filter: blur(6px) brightness(0.7);
            transition: filter 0.28s ease;
        }

        /* Spotify Music Player */
        #spotify-player {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 300;
        }

        #spotify-mini-player {
            background: linear-gradient(145deg, rgba(40, 20, 50, 0.95), rgba(25, 12, 35, 0.98));
            padding: 18px;
            border-radius: 20px;
            border: 1px solid rgba(255, 100, 180, 0.3);
            box-shadow:
                0 15px 50px rgba(0, 0, 0, 0.7),
                0 0 40px rgba(255, 20, 147, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.08),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(25px);
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 320px;
            transform: perspective(1000px) rotateX(2deg);
            transition: all 0.3s ease;
        }

        #spotify-mini-player:hover {
            transform: perspective(1000px) rotateX(0deg) translateY(-5px);
            box-shadow:
                0 25px 60px rgba(0, 0, 0, 0.8),
                0 0 60px rgba(255, 20, 147, 0.25);
        }

        #spotify-header {
            color: #ff69b4;
            font-size: 16px;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.5);
        }

        #spotify-url-input {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 150, 200, 0.25);
            border-radius: 12px;
            padding: 12px 15px;
            color: #ffd0e8;
            font-size: 12px;
            width: 100%;
            transition: all 0.2s ease;
        }

        #spotify-url-input:focus {
            border-color: rgba(255, 105, 180, 0.5);
            box-shadow: 0 0 15px rgba(255, 20, 147, 0.2);
            outline: none;
        }

        #spotify-url-input::placeholder {
            color: rgba(255, 200, 220, 0.4);
        }

        #spotify-load-btn {
            background: linear-gradient(135deg, #ff1493, #c71585);
            border: none;
            border-radius: 25px;
            padding: 12px 25px;
            color: white;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 5px 20px rgba(255, 20, 147, 0.4);
        }

        #spotify-load-btn:hover {
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 20, 147, 0.5);
        }

        #spotify-embed-container {
            border-radius: 15px;
            overflow: hidden;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        #spotify-embed-container iframe {
            border-radius: 15px;
        }

        #spotify-toggle {
            position: absolute;
            top: -45px;
            right: 0;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff1493, #c71585);
            border: 2px solid rgba(255, 200, 230, 0.3);
            color: white;
            font-size: 20px;
            cursor: pointer;
            box-shadow:
                0 5px 20px rgba(255, 20, 147, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            transition: all 0.2s ease;
        }

        #spotify-toggle:hover {
            transform: scale(1.15) rotate(10deg);
            box-shadow: 0 8px 30px rgba(255, 20, 147, 0.6);
        }

        #spotify-player.collapsed #spotify-mini-player {
            display: none;
        }

        #spotify-player.collapsed #spotify-toggle {
            top: 0;
        }

        #spotify-note {
            font-size: 11px;
            color: rgba(255, 180, 210, 0.6);
            text-align: center;
            margin-top: 8px;
        }

        #spotify-login-btn {
            background: linear-gradient(135deg, #ff1493, #c71585);
            border: none;
            border-radius: 25px;
            padding: 14px 30px;
            color: white;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            width: 100%;
            margin: 10px 0;
            box-shadow: 0 5px 25px rgba(255, 20, 147, 0.4);
            transition: all 0.2s ease;
        }

        #spotify-login-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 35px rgba(255, 20, 147, 0.5);
        }

        #spotify-album-art-container {
            width: 100%;
            display: flex;
            justify-content: center;
            margin-bottom: 12px;
        }

        #spotify-album-art {
            width: 180px;
            height: 180px;
            border-radius: 15px;
            object-fit: cover;
            box-shadow:
                0 10px 40px rgba(0, 0, 0, 0.5),
                0 0 30px rgba(255, 20, 147, 0.3);
        }

        #spotify-track-info {
            text-align: center;
            margin-bottom: 12px;
        }

        #spotify-track-name {
            color: #fff;
            font-size: 15px;
            font-weight: 700;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #spotify-artist-name {
            color: rgba(255, 180, 210, 0.8);
            font-size: 12px;
        }

        #spotify-progress-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        #spotify-progress-container span {
            font-size: 10px;
            color: rgba(255, 200, 220, 0.7);
            min-width: 35px;
        }

        #spotify-progress {
            flex: 1;
            -webkit-appearance: none;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            cursor: pointer;
        }

        #spotify-progress::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #ff1493;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 20, 147, 0.5);
        }

        #spotify-controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 10px;
        }

        #spotify-controls button {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(145deg, rgba(255, 80, 180, 0.3), rgba(180, 40, 140, 0.4));
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #spotify-controls button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.5);
        }

        #spotify-play {
            width: 55px !important;
            height: 55px !important;
            font-size: 22px !important;
            background: linear-gradient(135deg, #ff1493, #c71585) !important;
        }

        #spotify-volume-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #spotify-volume-container span {
            font-size: 14px;
        }

        #spotify-volume {
            flex: 1;
            -webkit-appearance: none;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            cursor: pointer;
        }

        #spotify-volume::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background: #ff69b4;
            border-radius: 50%;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="cursor"></div>
    <div class="code-rain" id="code-rain"></div>
    <div id="floating-hearts"></div>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-heart">üíñ</div>
        <div class="loading-text">Loading Love...</div>
    </div>

    <div id="controls">
        <button class="control-btn" onclick="setState('EXPLODE')">‚ú® 1. Explode</button>
        <button class="control-btn" onclick="setState('SPIRAL')">üåÄ 2. Spiral</button>
        <button class="control-btn" onclick="setState('CODE_HEART')">üíª 3. Code Heart</button>
        <button class="control-btn" onclick="setState('FLAPPY')">üéÆ 4. Flappy Heart</button>
    </div>

    <div id="state-indicator">Mode: <span id="current-state">HEART</span></div>

    <div id="ui-layer">
        <button id="btnStart" onclick="startSystem()">üíñ START LOVE üíñ</button>
    </div>

    <div id="copyright">üíñ Love Edition</div>
    <div id="canvas-container"></div>

    <!-- Spotify Web Playback SDK Player -->
    <div id="spotify-player">
        <button id="spotify-toggle" onclick="toggleSpotifyPlayer()">üéµ</button>
        <div id="spotify-mini-player">
            <!-- Not logged in state -->
            <div id="spotify-login-section">
                <div id="spotify-header">üéµ Spotify Premium</div>
                <button id="spotify-login-btn" onclick="spotifyLogin()">üîê ƒêƒÉng nh·∫≠p Spotify</button>
                <div id="spotify-note">C·∫ßn t√†i kho·∫£n Premium ƒë·ªÉ ph√°t nh·∫°c</div>
            </div>
            <!-- Playing state (hidden by default) -->
            <div id="spotify-playing-section" style="display:none;">
                <div id="spotify-album-art-container">
                    <img id="spotify-album-art" src="" alt="Album Art" />
                </div>
                <div id="spotify-track-info">
                    <div id="spotify-track-name">Ch∆∞a ph√°t nh·∫°c</div>
                    <div id="spotify-artist-name">---</div>
                </div>
                <div id="spotify-progress-container">
                    <span id="spotify-current-time">0:00</span>
                    <input type="range" id="spotify-progress" min="0" max="100" value="0" />
                    <span id="spotify-duration">0:00</span>
                </div>
                <div id="spotify-controls">
                    <button id="spotify-prev" onclick="spotifyPrev()">‚èÆ</button>
                    <button id="spotify-play" onclick="spotifyTogglePlay()">‚ñ∂</button>
                    <button id="spotify-next" onclick="spotifyNext()">‚è≠</button>
                </div>
                <div id="spotify-volume-container">
                    <span>üîä</span>
                    <input type="range" id="spotify-volume" min="0" max="100" value="50"
                        onchange="spotifySetVolume(this.value)" />
                </div>
            </div>
        </div>
    </div>

    <!-- Flappy Game -->
    <div id="flappy-game">
        <button id="back-btn" onclick="exitFlappyGame()">‚Üê Back</button>
        <div id="level-indicator">Lv.<span id="current-level">1</span> <span id="theme-name">üåÉ</span></div>
        <button id="show-leaderboard-btn" onclick="showLeaderboard()">üèÜ BXH</button>
        <button id="change-name-btn" onclick="changeName()">‚úèÔ∏è</button>
        <div id="player-info-bar">
            <div id="player-name-display">üë§ <span id="current-player-name">...</span></div>
            <div id="player-lives-display"><span id="player-lives">üíñ</span></div>
            <div id="player-best-display">üèÖ<span id="player-best">0</span></div>
        </div>
        <div id="flappy-score">0</div>
        <canvas id="flappy-canvas"></canvas>
        <div id="active-effects"></div>
        <div id="flappy-instructions">
            <h2>üíñ Flappy Heart Pro üíñ</h2>
            <p>Nh·∫•n <b>SPACE</b> ho·∫∑c <b>CLICK</b> ƒë·ªÉ bay</p>
            <p>Tr√°nh c√°c c·ªôt v√† v·∫≠t c·∫£n ƒë·ªÉ ghi ƒëi·ªÉm!</p>
            <p style="margin-top:10px;color:#00ff7f;">üíö ƒÇn power-ups ƒë·ªÉ nh·∫≠n buff</p>
            <p style="color:#ff4444;">‚ùå Tr√°nh obstacles nguy hi·ªÉm</p>
            <p style="margin-top: 20px; color: #ffd700;">Nh·∫•n ƒë·ªÉ b·∫Øt ƒë·∫ßu...</p>
        </div>
        <div id="game-over-screen">
            <h2>üíî Game Over üíî</h2>
            <div id="final-score">0</div>
            <div id="final-level" style="color:#ffd700;font-size:18px;margin:10px 0;">Level: 1</div>
            <div id="high-score">High Score: 0</div>
            <button onclick="restartFlappyGame()">üîÑ Ch∆°i l·∫°i</button>
            <button onclick="showLeaderboard()"
                style="margin-top:10px; background:linear-gradient(135deg,#8a2be2,#4b0082);">üèÜ Xem BXH</button>
        </div>
    </div>
    <div id="level-up-toast">üéâ LEVEL UP! üéâ</div>
    <div id="level-transition" class="hidden">
        <div class="lt-box">
            <div class="lt-icon" id="lt-icon">üåÉ</div>
            <div class="lt-text" id="lt-text">Level 1 ‚Äî üåÉ</div>
        </div>
    </div>

    <!-- Name Input Modal -->
    <div id="name-modal">
        <h3>üéÆ Ch√†o m·ª´ng ƒë·∫øn Flappy Heart!</h3>
        <p>Ch·ªçn avatar v√† nh·∫≠p t√™n ƒë·ªÉ l√™n b·∫£ng x·∫øp h·∫°ng</p>
        <div class="avatar-select">
            <span class="avatar-option selected" data-avatar="üíñ" onclick="selectAvatar(this)">üíñ</span>
            <span class="avatar-option" data-avatar="ü¶ã" onclick="selectAvatar(this)">ü¶ã</span>
            <span class="avatar-option" data-avatar="üåü" onclick="selectAvatar(this)">üåü</span>
            <span class="avatar-option" data-avatar="üî•" onclick="selectAvatar(this)">üî•</span>
            <span class="avatar-option" data-avatar="üëë" onclick="selectAvatar(this)">üëë</span>
        </div>
        <input type="text" id="player-name-input" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n..." maxlength="15">
        <br>
        <button id="submit-name" onclick="submitPlayerName()">üöÄ B·∫Øt ƒë·∫ßu ch∆°i!</button>
    </div>

    <!-- Leaderboard -->
    <div id="leaderboard">
        <h3>üèÜ B·∫£ng X·∫øp H·∫°ng üèÜ</h3>
        <ul id="leaderboard-list"></ul>
        <button id="close-leaderboard" onclick="hideLeaderboard()">ƒê√≥ng</button>
    </div>

    <script>
        // Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyBxM1OGoEKGEjy923zb4xHJxsNDOcuG5xg",
            authDomain: "love-heart-game.firebaseapp.com",
            databaseURL: "https://love-heart-game-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "love-heart-game",
            storageBucket: "love-heart-game.firebasestorage.app",
            messagingSenderId: "355212210596",
            appId: "1:355212210596:web:098a00d66c184f7efe9131"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // Player name and avatar
        let playerName = localStorage.getItem('playerName') || '';
        let playerAvatar = localStorage.getItem('playerAvatar') || 'üíñ';

        function selectAvatar(el) {
            document.querySelectorAll('.avatar-option').forEach(a => a.classList.remove('selected'));
            el.classList.add('selected');
            playerAvatar = el.dataset.avatar;
        }

        function askPlayerName() {
            if (!playerName) {
                document.getElementById('name-modal').style.display = 'block';
            }
        }

        function submitPlayerName() {
            const name = document.getElementById('player-name-input').value.trim();
            if (name) {
                playerName = name;
                localStorage.setItem('playerName', name);
                localStorage.setItem('playerAvatar', playerAvatar);
                document.getElementById('name-modal').style.display = 'none';
                updatePlayerNameDisplay();
            }
        }

        function changeName() {
            document.getElementById('player-name-input').value = playerName;
            document.getElementById('name-modal').style.display = 'block';
            // Select current avatar
            document.querySelectorAll('.avatar-option').forEach(a => {
                a.classList.toggle('selected', a.dataset.avatar === playerAvatar);
            });
        }

        function updatePlayerNameDisplay() {
            const el = document.getElementById('current-player-name');
            if (el) el.textContent = playerAvatar + ' ' + (playerName || 'Ch∆∞a ƒë·∫∑t t√™n');
            const bestEl = document.getElementById('player-best');
            if (bestEl) bestEl.textContent = localStorage.getItem('flappyHS') || 0;
        }

        // Spotify Web Playback SDK
        const SPOTIFY_CLIENT_ID = '799ab64811454ec78d5f47e21729cc7a';
        const SPOTIFY_REDIRECT_URI = 'https://cooksanji201-web.github.io/love-heart/index-heart-love.html';
        const SPOTIFY_SCOPES = 'streaming user-read-email user-read-private user-read-playback-state user-modify-playback-state';

        let spotifyPlayer = null;
        let spotifyDeviceId = null;
        let spotifyToken = null;
        let spotifyIsPlaying = false;

        // Check for auth code in URL after OAuth redirect (PKCE flow)
        async function checkSpotifyAuth() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');

            if (code) {
                const codeVerifier = localStorage.getItem('spotify_code_verifier');
                if (codeVerifier) {
                    await exchangeCodeForToken(code, codeVerifier);
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            } else {
                const savedToken = localStorage.getItem('spotify_token');
                if (savedToken) {
                    spotifyToken = savedToken;
                    initSpotifyPlayer();
                }
            }
        }

        async function spotifyLogin() {
            const codeVerifier = generateRandomString(128);
            const codeChallenge = await generateCodeChallenge(codeVerifier);
            localStorage.setItem('spotify_code_verifier', codeVerifier);

            const authUrl = `https://accounts.spotify.com/authorize?client_id=${SPOTIFY_CLIENT_ID}&response_type=code&redirect_uri=${encodeURIComponent(SPOTIFY_REDIRECT_URI)}&scope=${encodeURIComponent(SPOTIFY_SCOPES)}&code_challenge_method=S256&code_challenge=${codeChallenge}`;
            window.location.href = authUrl;
        }

        function generateRandomString(length) {
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            return Array.from(crypto.getRandomValues(new Uint8Array(length)))
                .map(x => possible[x % possible.length]).join('');
        }

        async function generateCodeChallenge(verifier) {
            const data = new TextEncoder().encode(verifier);
            const digest = await crypto.subtle.digest('SHA-256', data);
            return btoa(String.fromCharCode(...new Uint8Array(digest)))
                .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }

        async function exchangeCodeForToken(code, codeVerifier) {
            const response = await fetch('https://accounts.spotify.com/api/token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: new URLSearchParams({
                    client_id: SPOTIFY_CLIENT_ID,
                    grant_type: 'authorization_code',
                    code: code,
                    redirect_uri: SPOTIFY_REDIRECT_URI,
                    code_verifier: codeVerifier
                })
            });
            const data = await response.json();
            if (data.access_token) {
                spotifyToken = data.access_token;
                localStorage.setItem('spotify_token', data.access_token);
                initSpotifyPlayer();
            }
        }

        function initSpotifyPlayer() {
            const script = document.createElement('script');
            script.src = 'https://sdk.scdn.co/spotify-player.js';
            document.body.appendChild(script);

            window.onSpotifyWebPlaybackSDKReady = () => {
                spotifyPlayer = new Spotify.Player({
                    name: 'Magic Heart Player üíñ',
                    getOAuthToken: cb => { cb(spotifyToken); },
                    volume: 0.5
                });

                spotifyPlayer.addListener('ready', ({ device_id }) => {
                    spotifyDeviceId = device_id;
                    document.getElementById('spotify-login-section').style.display = 'none';
                    document.getElementById('spotify-playing-section').style.display = 'block';
                    transferPlayback(device_id);
                });

                spotifyPlayer.addListener('player_state_changed', state => {
                    if (!state) return;
                    updateSpotifyUI(state);
                });

                spotifyPlayer.addListener('authentication_error', ({ message }) => {
                    localStorage.removeItem('spotify_token');
                    document.getElementById('spotify-login-section').style.display = 'block';
                    document.getElementById('spotify-playing-section').style.display = 'none';
                });

                spotifyPlayer.addListener('account_error', ({ message }) => {
                    alert('C·∫ßn t√†i kho·∫£n Spotify Premium!');
                });

                spotifyPlayer.connect();
            };
        }

        function transferPlayback(deviceId) {
            fetch('https://api.spotify.com/v1/me/player', {
                method: 'PUT',
                headers: { 'Authorization': `Bearer ${spotifyToken}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ device_ids: [deviceId], play: false })
            });
        }

        function updateSpotifyUI(state) {
            const track = state.track_window.current_track;
            spotifyIsPlaying = !state.paused;
            document.getElementById('spotify-track-name').textContent = track.name;
            document.getElementById('spotify-artist-name').textContent = track.artists.map(a => a.name).join(', ');
            document.getElementById('spotify-album-art').src = track.album.images[0]?.url || '';
            document.getElementById('spotify-play').textContent = spotifyIsPlaying ? '‚è∏' : '‚ñ∂';
            document.getElementById('spotify-current-time').textContent = formatTime(state.position);
            document.getElementById('spotify-duration').textContent = formatTime(state.duration);
            document.getElementById('spotify-progress').value = (state.position / state.duration) * 100;
        }

        function formatTime(ms) {
            const sec = Math.floor(ms / 1000);
            return `${Math.floor(sec / 60)}:${(sec % 60).toString().padStart(2, '0')}`;
        }

        function spotifyTogglePlay() { if (spotifyPlayer) spotifyPlayer.togglePlay(); }
        function spotifyPrev() { if (spotifyPlayer) spotifyPlayer.previousTrack(); }
        function spotifyNext() { if (spotifyPlayer) spotifyPlayer.nextTrack(); }
        function spotifySetVolume(val) { if (spotifyPlayer) spotifyPlayer.setVolume(val / 100); }

        function toggleSpotifyPlayer() {
            const player = document.getElementById('spotify-player');
            player.classList.toggle('collapsed');
            document.getElementById('spotify-toggle').textContent = player.classList.contains('collapsed') ? 'üéµ' : '‚úï';
        }

        checkSpotifyAuth();

        // Leaderboard functions
        function saveScore(score, level) {
            if (!playerName || score <= 0) return;
            const scoreRef = database.ref('leaderboard').push();
            scoreRef.set({
                name: playerName,
                avatar: playerAvatar,
                score: score,
                level: level || 1,
                timestamp: Date.now()
            });
        }

        function showLeaderboard() {
            document.getElementById('leaderboard').style.display = 'block';
            loadLeaderboard();
        }

        function hideLeaderboard() {
            document.getElementById('leaderboard').style.display = 'none';
        }

        function loadLeaderboard() {
            const list = document.getElementById('leaderboard-list');
            list.innerHTML = '<li style="justify-content:center;color:#ff69b4;">ƒêang t·∫£i...</li>';

            database.ref('leaderboard').orderByChild('score').limitToLast(10).once('value', snapshot => {
                const scores = [];
                snapshot.forEach(child => {
                    scores.push(child.val());
                });
                scores.sort((a, b) => b.score - a.score);

                list.innerHTML = '';
                if (scores.length === 0) {
                    list.innerHTML = '<li style="justify-content:center;color:#888;">Ch∆∞a c√≥ ƒëi·ªÉm</li>';
                    return;
                }
                const rankIcons = ['ü•á', 'ü•à', 'ü•â'];
                scores.forEach((item, i) => {
                    const li = document.createElement('li');
                    const rankDisplay = i < 3 ? rankIcons[i] : `#${i + 1}`;
                    const avatar = item.avatar || 'üíñ';
                    li.innerHTML = `<span class="rank">${rankDisplay}</span><span class="player-name">${avatar} ${item.name}</span><span class="player-score">${item.score}</span>`;
                    list.appendChild(li);
                });
            });
        }

        // Cursor
        document.addEventListener('mousemove', e => {
            document.getElementById('cursor').style.left = e.clientX + 'px';
            document.getElementById('cursor').style.top = e.clientY + 'px';
            mouseX = e.clientX / innerWidth;
            mouseY = e.clientY / innerHeight;
            if (Math.random() > 0.7) {
                const t = document.createElement('div');
                t.className = 'trail';
                t.textContent = ['üíñ', 'üíï', '‚ú®', 'üí´'][Math.floor(Math.random() * 4)];
                t.style.left = e.clientX + 'px';
                t.style.top = e.clientY + 'px';
                document.body.appendChild(t);
                setTimeout(() => t.remove(), 800);
            }
        });

        // Config
        const loader = new THREE.TextureLoader();
        const photoFiles = ['./image1.jpeg', './image2.jpeg', './image3.jpeg', './image4.jpeg', './image5.jpeg'];
        const photoTextures = photoFiles.map(f => loader.load(f));

        let scene, camera, renderer, groupMain, groupSecondary, groupHearts, photoMeshes = [], loveMesh, titleMesh;
        let state = 'HEART', mouseX = 0.5, mouseY = 0.5, tiltAngle = 0, targetTilt = 0, isDragging = false;
        const CONFIG = { particleCount1: 1200, particleCount2: 300, heartCount: 120, explodeRadius: 70, photoOrbitRadius: 25, spiralHeight: 80 };

        function createGlowTexture(c1, c2) {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createRadialGradient(64, 64, 0, 64, 64, 50);
            grd.addColorStop(0, '#fff'); grd.addColorStop(0.3, c1); grd.addColorStop(0.7, c2); grd.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grd; ctx.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function createHeartTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ff1493'; ctx.shadowColor = '#ff69b4'; ctx.shadowBlur = 10;
            ctx.beginPath(); ctx.moveTo(32, 20);
            ctx.bezierCurveTo(32, 16, 24, 8, 16, 16); ctx.bezierCurveTo(4, 24, 16, 40, 32, 52);
            ctx.bezierCurveTo(48, 40, 60, 24, 48, 16); ctx.bezierCurveTo(40, 8, 32, 16, 32, 20);
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        const textures = { glow1: createGlowTexture('#ff1493', '#ff69b4'), glow2: createGlowTexture('#8a2be2', '#9370db'), heart: createHeartTexture() };

        function createCodeRain() {
            const container = document.getElementById('code-rain');
            const snippets = ['love++', '‚ù§Ô∏è', 'if(love)', 'return you', 'while(true)', 'heart = full', 'you && me', 'forever()', 'üíï', 'üíñ'];
            for (let i = 0; i < 12; i++) {
                const col = document.createElement('div');
                col.className = 'code-column';
                col.style.left = (i * 7.5) + '%';
                col.style.animationDuration = (9 + Math.random() * 10) + 's';
                col.style.animationDelay = (Math.random() * 5) + 's';
                let text = '';
                for (let j = 0; j < 20; j++) text += snippets[Math.floor(Math.random() * snippets.length)] + '<br>';
                col.innerHTML = text;
                container.appendChild(col);
            }
            container.style.opacity = '0.12';
        }

        function createFloatingHearts() {
            const container = document.getElementById('floating-hearts');
            setInterval(() => {
                const h = document.createElement('div');
                h.className = 'floating-heart';
                h.innerHTML = ['üíñ', 'üíó', 'üíï', '‚ù§Ô∏è', 'üíò'][Math.floor(Math.random() * 5)];
                h.style.left = Math.random() * 100 + '%';
                h.style.fontSize = (15 + Math.random() * 20) + 'px';
                h.style.animationDuration = (5 + Math.random() * 5) + 's';
                container.appendChild(h);
                setTimeout(() => h.remove(), 9000);
            }, 1200);
        }

        let composer; // Post-processing composer

        function init3D() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a0f, 0.003);
            camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
            camera.position.z = 100;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Setup Post-processing with Bloom
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(innerWidth, innerHeight),
                1.2,   // strength - glow intensity
                0.4,   // radius - spread
                0.85   // threshold - only bright pixels glow
            );
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            groupMain = createParticleSystem('glow1', CONFIG.particleCount1, 2.5);
            groupSecondary = createParticleSystem('glow2', CONFIG.particleCount2, 3.5);
            groupHearts = createParticleSystem('heart', CONFIG.heartCount, 4.0);
            createPhotos();
            createDecorations();
            animate();
        }

        function createParticleSystem(type, count, size) {
            const pPos = [], pHeart = [], pExplode = [], pSpiral = [], pCode = [], phases = [];
            for (let i = 0; i < count; i++) {
                const t = Math.random() * Math.PI * 2;
                let hx = 16 * Math.pow(Math.sin(t), 3);
                let hy = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                const r = Math.pow(Math.random(), 0.3);
                pHeart.push(hx * r * 2.5, hy * r * 2.5 + 5, (Math.random() - 0.5) * 10 * r);

                const u = Math.random(), v = Math.random();
                const phi = Math.acos(2 * v - 1), lam = 2 * Math.PI * u;
                const rad = CONFIG.explodeRadius * Math.cbrt(Math.random());
                pExplode.push(rad * Math.sin(phi) * Math.cos(lam), rad * Math.sin(phi) * Math.sin(lam), rad * Math.cos(phi));

                const sT = (i / count) * Math.PI * 8, sR = 20 + (i / count) * 30, sY = -CONFIG.spiralHeight / 2 + (i / count) * CONFIG.spiralHeight;
                pSpiral.push(Math.cos(sT) * sR, sY, Math.sin(sT) * sR);

                const eT = (i / count) * Math.PI * 2;
                let cx = 16 * Math.pow(Math.sin(eT), 3);
                let cy = 13 * Math.cos(eT) - 5 * Math.cos(2 * eT) - 2 * Math.cos(3 * eT) - Math.cos(4 * eT);
                const out = 0.85 + Math.random() * 0.15;
                pCode.push(cx * 4 * out, cy * 4 * out + 5, (Math.random() - 0.5) * 15);

                pPos.push(pHeart[i * 3], pHeart[i * 3 + 1], pHeart[i * 3 + 2]);
                phases.push(Math.random() * Math.PI * 2);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
            const colors = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) { colors[i * 3] = 1; colors[i * 3 + 1] = 0.4; colors[i * 3 + 2] = 0.7; }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.userData = { heart: pHeart, explode: pExplode, spiral: pSpiral, codeHeart: pCode, phases };
            const mat = new THREE.PointsMaterial({ size, map: textures[type], transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false });
            const pts = new THREE.Points(geo, mat);
            scene.add(pts);
            return pts;
        }

        function createPhotos() {
            const geo = new THREE.PlaneGeometry(8, 8);
            for (let i = 0; i < 5; i++) {
                const mat = new THREE.MeshBasicMaterial({ map: photoTextures[i], side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.visible = false;
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function createDecorations() {
            const c1 = document.createElement('canvas'); c1.width = 1024; c1.height = 256;
            const ctx1 = c1.getContext('2d');
            ctx1.font = 'bold 100px "Fira Code"'; ctx1.fillStyle = '#ff1493'; ctx1.textAlign = 'center';
            ctx1.shadowColor = '#ff69b4'; ctx1.shadowBlur = 40;
            ctx1.fillText("üíñ LOVE üíñ", 512, 140);
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c1), transparent: true, blending: THREE.AdditiveBlending }));
            titleMesh.position.set(0, 55, 0);
            scene.add(titleMesh);

            const c2 = document.createElement('canvas'); c2.width = 1024; c2.height = 256;
            const ctx2 = c2.getContext('2d');
            ctx2.font = 'bold 90px "Fira Code"'; ctx2.fillStyle = '#ff69b4'; ctx2.textAlign = 'center';
            ctx2.shadowColor = '#ff1493'; ctx2.shadowBlur = 30;
            ctx2.fillText("I LOVE YOU ‚ù§Ô∏è", 512, 140);
            loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c2), transparent: true, blending: THREE.AdditiveBlending }));
            loveMesh.position.set(0, 0, 20);
            scene.add(loveMesh);
        }

        function updateParticles(group, speed, rotY, time) {
            const pos = group.geometry.attributes.position.array;
            const col = group.geometry.attributes.color.array;
            const { phases } = group.geometry.userData;
            const key = state === 'SPIRAL' ? 'spiral' : state === 'CODE_HEART' ? 'codeHeart' : state === 'HEART' ? 'heart' : 'explode';
            const targets = group.geometry.userData[key];
            for (let i = 0; i < pos.length; i++) pos[i] += (targets[i] - pos[i]) * speed;
            group.geometry.attributes.position.needsUpdate = true;
            const count = pos.length / 3;
            if (state === 'HEART' || state === 'CODE_HEART') {
                group.rotation.y += (rotY - group.rotation.y) * 0.1;
                tiltAngle += (targetTilt - tiltAngle) * 0.1;
                group.rotation.x = tiltAngle * Math.PI / 180;
                const beat = 1 + Math.abs(Math.sin(time * 3)) * 0.15;
                group.scale.set(beat, beat, beat);
            } else if (state === 'SPIRAL') {
                group.rotation.y += 0.01;
                group.scale.set(1, 1, 1);
            } else {
                group.rotation.y += (rotY - group.rotation.y) * 0.1;
                group.scale.set(1, 1, 1);
            }
            for (let i = 0; i < count; i++) {
                const b = 0.7 + 0.5 * Math.sin(time * 5 + phases[i]);
                col[i * 3] = b; col[i * 3 + 1] = 0.4 * b; col[i * 3 + 2] = 0.7 * b;
            }
            group.geometry.attributes.color.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const rotY = (mouseX - 0.5) * 4;
            updateParticles(groupMain, 0.08, rotY, time);
            updateParticles(groupSecondary, 0.08, rotY, time);
            updateParticles(groupHearts, 0.08, rotY, time);

            if (state === 'HEART' || state === 'CODE_HEART') {
                titleMesh.visible = true; loveMesh.visible = true;
                const s = 1 + Math.abs(Math.sin(time * 3)) * 0.1;
                loveMesh.scale.set(s, s, 1);
                photoMeshes.forEach(m => m.visible = false);
            } else if (state === 'SPIRAL') {
                titleMesh.visible = false; loveMesh.visible = true;
                photoMeshes.forEach(m => m.visible = false);
            } else if (state === 'EXPLODE') {
                titleMesh.visible = false; loveMesh.visible = false;
                const baseAngle = groupMain.rotation.y;
                photoMeshes.forEach((mesh, i) => {
                    mesh.visible = true;
                    const angle = baseAngle + i * (Math.PI * 2 / 5);
                    mesh.position.lerp(new THREE.Vector3(Math.sin(angle) * CONFIG.photoOrbitRadius, Math.sin(time + i) * 3, Math.cos(angle) * CONFIG.photoOrbitRadius), 0.1);
                    mesh.lookAt(camera.position);
                });
            }
            // Use composer for bloom effect, fallback to renderer
            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        function setState(newState) {
            if (newState === 'FLAPPY') { startFlappyGame(); return; }
            state = newState;
            document.getElementById('current-state').textContent = newState;
            hideFlappyGame();
        }

        function startSystem() {
            // Show loading screen
            const loading = document.getElementById('loading-screen');
            loading.style.display = 'flex';
            document.getElementById('ui-layer').style.display = 'none';

            // Spawn falling roses like opening a book
            setTimeout(() => {
                for (let i = 0; i < 50; i++) {
                    setTimeout(() => {
                        const rose = document.createElement('div');
                        rose.className = 'falling-rose';
                        rose.textContent = ['üåπ', 'üå∏', 'üå∫', 'üíê', 'üå∑'][Math.floor(Math.random() * 5)];
                        rose.style.left = Math.random() * 100 + '%';
                        rose.style.top = '-50px';
                        rose.style.fontSize = (20 + Math.random() * 25) + 'px';
                        rose.style.animationDuration = (3 + Math.random() * 3) + 's';
                        document.body.appendChild(rose);
                        setTimeout(() => rose.remove(), 6000);
                    }, i * 60);
                }
            }, 500);

            // After loading, show main content
            setTimeout(() => {
                loading.style.display = 'none';
                document.getElementById('controls').style.display = 'block';
                document.getElementById('state-indicator').style.display = 'block';
                createCodeRain();
                createFloatingHearts();
                init3D();
            }, 2000);
        }

        document.addEventListener('keydown', e => {
            if (e.key === '1') setState('HEART');
            if (e.key === '2') setState('EXPLODE');
            if (e.key === '3') setState('SPIRAL');
            if (e.key === '4') setState('CODE_HEART');
            if (e.key === '5') setState('FLAPPY');
            if (e.key === ' ' && state === 'FLAPPY') flappyJump();
        });

        addEventListener('resize', () => {
            if (camera) { camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }
        });

        // FLAPPY GAME PRO
        let flappyCanvas, flappyCtx, flappyBird = { x: 100, y: 300, velocity: 0, radius: 25 };
        let flappyPipes = [], flappyScore = 0, flappyHighScore = localStorage.getItem('flappyHS') || 0;
        let flappyRunning = false, flappyStarted = false, flappyAnimId = null;

        // Level & Difficulty System
        let currentLevel = 1, lastLevel = 0;
        // 7 themes: city, forest, sakura, ocean, space, tet
        const THEMES = ['city', 'forest', 'sakura', 'ocean', 'space', 'tet'];
        let currentTheme = 'city';

        // Power-ups & Items with RARITY (lower = rarer)
        let gameItems = [], activeEffects = {};
        let shurikens = []; // Flying shurikens from right to left
        let playerLives = 1; // Start with 1 life

        // Items - EQUAL RARITY for variety
        // Final item set: only shield and heart (good), bomb (bad)
        const POWERUPS = [
            { type: 'shield', icon: 'üõ°Ô∏è', color: '#00ff7f', duration: 0, rarity: 18 },
            { type: 'heart', icon: 'üíñ', color: '#ff1493', duration: 0, rarity: 14 }
        ];

        const OBSTACLES = [
            { type: 'bomb', icon: 'üí£', color: '#ff4444', rarity: 20 }
        ];

        // Dynamic game settings based on level
        function getGameSettings() {
            const l = currentLevel;
            return {
                gravity: 0.35 + Math.min(l * 0.01, 0.15),
                jump: -8 + Math.min(l * 0.1, 1),
                pipeSpeed: 2.5 + Math.min(l * 0.15, 2.5),
                pipeGap: Math.max(240 - l * 4, 150),
                spawnRate: Math.max(350 - l * 6, 250),
                itemChance: Math.min(0.22 + l * 0.02, 0.45)  // Reduced item spawn rate for clarity
            };
        }
        const PIPE_WIDTH = 70;

        function initFlappyCanvas() {
            flappyCanvas = document.getElementById('flappy-canvas');
            flappyCtx = flappyCanvas.getContext('2d');
            flappyCanvas.width = innerWidth;
            flappyCanvas.height = innerHeight;
        }

        function startFlappyGame() {
            state = 'FLAPPY';
            document.getElementById('flappy-game').style.display = 'block';
            document.getElementById('flappy-instructions').style.display = 'block';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            initFlappyCanvas();
            resetFlappyGame();
            flappyGameLoop();
            // Show player name and ask if not set
            updatePlayerNameDisplay();
            askPlayerName();
        }

        function hideFlappyGame() {
            document.getElementById('flappy-game').style.display = 'none';
            if (flappyAnimId) cancelAnimationFrame(flappyAnimId);
            flappyRunning = false; flappyStarted = false;
            document.getElementById('controls').style.display = 'block';
        }

        function exitFlappyGame() { setState('HEART'); }

        function resetFlappyGame() {
            flappyBird = { x: 100, y: innerHeight / 2, velocity: 0, radius: 25, baseRadius: 25 };
            flappyPipes = []; flappyScore = 0; flappyRunning = false; flappyStarted = false;
            currentLevel = 1; lastLevel = 0; currentTheme = 'city';
            gameItems = []; activeEffects = {};
            playerLives = 1;
            lastGapY = 0;
            pipeCounter = 0;
            itemAlternator = true;
            itemHistory = [];
            bgScrollX = 0;
            initFlappyBackground();
            updateLevelUI();
            updateLivesUI();
            document.getElementById('flappy-score').textContent = '0';
            document.getElementById('high-score').textContent = 'High Score: ' + flappyHighScore;
            document.getElementById('active-effects').innerHTML = '';
        }

        function updateLevelUI() {
            document.getElementById('current-level').textContent = currentLevel;
            const themeNames = {
                city: 'üåÉ', forest: 'üå≤', sakura: 'üå∏',
                ocean: 'üåä', space: 'üöÄ', tet: 'üßß'
            };
            document.getElementById('theme-name').textContent = themeNames[currentTheme] || 'üåÉ';
        }

        // Smooth theme transition overlay
        let themeTransition = 0;
        function triggerThemeTransition() {
            themeTransition = 1;
        }

        function showLevelUp() {
            const toast = document.getElementById('level-up-toast');
            toast.textContent = `üéâ LEVEL ${currentLevel}! üéâ`;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 1500);
        }

        function showLevelTransition() {
            // Simple toast without blur - less intrusive
            const toast = document.getElementById('level-up-toast');
            const themes = { city: 'üåÉ', forest: 'üå≤', sakura: 'üå∏', ocean: 'üåä', space: 'üöÄ', tet: 'üßß' };
            const emoji = themes[currentTheme] || 'üåÉ';
            toast.textContent = `${emoji} Level ${currentLevel}!`;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 800);
        }

        function updateLevel() {
            const newLevel = Math.floor(flappyScore / 5) + 1;
            if (newLevel > currentLevel) {
                currentLevel = newLevel;
                // Change theme every 4 levels
                const themeIndex = Math.min(Math.floor((currentLevel - 1) / 4), THEMES.length - 1);
                if (THEMES[themeIndex] !== currentTheme) {
                    currentTheme = THEMES[themeIndex];
                    triggerThemeTransition();
                    initFlappyBackground();
                }
                updateLevelUI();
                // Show a compact transition overlay and blur the game (no big toast text)
                showLevelTransition();
            }
        }

        // Background elements
        let bgScrollX = 0;
        let buildings = [], stars = [], clouds = [], floatingObjs = [];

        function initFlappyBackground() {
            buildings = []; stars = []; clouds = []; floatingObjs = [];

            if (currentTheme === 'city') {
                // City - Buildings with neon lights
                for (let layer = 0; layer < 3; layer++) {
                    const count = 8 + layer * 3;
                    for (let i = 0; i < count; i++) {
                        buildings.push({
                            x: i * (innerWidth / count) * 1.5 + Math.random() * 50,
                            width: 40 + Math.random() * 60 + layer * 20,
                            height: 80 + Math.random() * 150 + layer * 50,
                            layer, windows: Math.floor(3 + Math.random() * 6),
                            color: layer === 0 ? '#1a0025' : layer === 1 ? '#2a0040' : '#3a0055'
                        });
                    }
                }
                for (let i = 0; i < 80; i++) stars.push({ x: Math.random() * innerWidth, y: Math.random() * innerHeight * 0.6, size: 0.5 + Math.random() * 2, twinkle: Math.random() * Math.PI * 2 });
                const cityObjs = ['üíñ', '‚≠ê', 'üåô', '‚ú®', 'üí´'];
                for (let i = 0; i < 12; i++) floatingObjs.push({ x: Math.random() * innerWidth * 2, y: 100 + Math.random() * (innerHeight - 300), type: cityObjs[Math.floor(Math.random() * cityObjs.length)], size: 15 + Math.random() * 20, speed: 1 + Math.random() * 2, wobble: Math.random() * Math.PI * 2 });
            } else if (currentTheme === 'forest') {
                // Mystical Forest - Trees, fireflies, mushrooms
                for (let layer = 0; layer < 3; layer++) {
                    const count = 5 + layer * 2;
                    for (let i = 0; i < count; i++) {
                        buildings.push({ x: i * (innerWidth / count) * 1.5, width: 60 + Math.random() * 80, height: 100 + layer * 60 + Math.random() * 80, layer, isTree: true, color: layer === 0 ? '#0a1510' : layer === 1 ? '#122a1a' : '#1a4025' });
                    }
                }
                for (let i = 0; i < 60; i++) stars.push({ x: Math.random() * innerWidth, y: Math.random() * innerHeight * 0.7, size: 1 + Math.random() * 2, twinkle: Math.random() * Math.PI * 2, isFirefly: true });
                const forestObjs = ['üçÑ', 'üåô', 'ü¶ã', '‚ú®', 'üåø', 'üçÉ', 'ü¶â'];
                for (let i = 0; i < 15; i++) floatingObjs.push({ x: Math.random() * innerWidth * 2, y: 100 + Math.random() * (innerHeight - 280), type: forestObjs[Math.floor(Math.random() * forestObjs.length)], size: 18 + Math.random() * 22, speed: 0.6 + Math.random() * 1.2, wobble: Math.random() * Math.PI * 2 });
            } else if (currentTheme === 'sakura') {
                // Cherry Blossom - Trees, falling petals, lanterns
                for (let layer = 0; layer < 3; layer++) {
                    const count = 4 + layer * 2;
                    for (let i = 0; i < count; i++) {
                        buildings.push({ x: i * (innerWidth / count) * 1.5, width: 50 + Math.random() * 70, height: 90 + layer * 50 + Math.random() * 60, layer, isSakuraTree: true, color: layer === 0 ? '#1a0820' : layer === 1 ? '#2a1030' : '#3a1545' });
                    }
                }
                for (let i = 0; i < 50; i++) stars.push({ x: Math.random() * innerWidth, y: Math.random() * innerHeight * 0.8, size: 0.8 + Math.random() * 1.5, twinkle: Math.random() * Math.PI * 2 });
                // Falling petals
                for (let i = 0; i < 30; i++) clouds.push({ x: Math.random() * innerWidth, y: Math.random() * innerHeight, size: 8 + Math.random() * 12, speed: 0.3 + Math.random() * 0.5, isPetal: true });
                const sakuraObjs = ['üå∏', 'üèÆ', 'üéã', '‚ú®', 'üíÆ', 'üåô', 'üéê'];
                for (let i = 0; i < 14; i++) floatingObjs.push({ x: Math.random() * innerWidth * 2, y: 80 + Math.random() * (innerHeight - 250), type: sakuraObjs[Math.floor(Math.random() * sakuraObjs.length)], size: 18 + Math.random() * 25, speed: 0.7 + Math.random() * 1.3, wobble: Math.random() * Math.PI * 2 });
            } else if (currentTheme === 'ocean') {
                // Ocean - Coral, fish, bubbles
                for (let layer = 0; layer < 3; layer++) {
                    const count = 6 + layer * 2;
                    for (let i = 0; i < count; i++) {
                        buildings.push({ x: i * (innerWidth / count) * 1.5, width: 30 + Math.random() * 50, height: 50 + layer * 30 + Math.random() * 80, layer, isCoral: true, color: ['#ff6b6b', '#4ecdc4', '#ffe66d', '#6b5b95'][Math.floor(Math.random() * 4)] });
                    }
                }
                for (let i = 0; i < 40; i++) clouds.push({ x: Math.random() * innerWidth, y: Math.random() * innerHeight, size: 3 + Math.random() * 8, speed: 0.5 + Math.random(), isBubble: true });
                const oceanObjs = ['üê†', 'üêü', 'ü¶Ä', 'üêö', 'üåä', 'üêô', 'ü¶ë', 'üê°'];
                for (let i = 0; i < 15; i++) floatingObjs.push({ x: Math.random() * innerWidth * 2, y: 80 + Math.random() * (innerHeight - 200), type: oceanObjs[Math.floor(Math.random() * oceanObjs.length)], size: 20 + Math.random() * 30, speed: 1 + Math.random() * 2, wobble: Math.random() * Math.PI * 2 });
            } else if (currentTheme === 'space') {
                // Space - Planets, nebula, asteroids
                for (let i = 0; i < 150; i++) stars.push({ x: Math.random() * innerWidth, y: Math.random() * innerHeight, size: 0.5 + Math.random() * 3, twinkle: Math.random() * Math.PI * 2 });
                for (let i = 0; i < 4; i++) buildings.push({ x: Math.random() * innerWidth, y: 100 + Math.random() * (innerHeight - 300), width: 40 + Math.random() * 80, isPlanet: true, color: ['#ff6347', '#4169e1', '#9370db', '#ffd700'][i] });
                const spaceObjs = ['üöÄ', 'üõ∏', '‚òÑÔ∏è', 'üåü', 'üí´', 'üåç', 'üåô'];
                for (let i = 0; i < 12; i++) floatingObjs.push({ x: Math.random() * innerWidth * 2, y: 80 + Math.random() * (innerHeight - 200), type: spaceObjs[Math.floor(Math.random() * spaceObjs.length)], size: 20 + Math.random() * 35, speed: 0.5 + Math.random() * 1.5, wobble: Math.random() * Math.PI * 2 });
            } else if (currentTheme === 'tet') {
                // Vietnamese Tet - Lanterns, mai flowers, fireworks
                for (let layer = 0; layer < 3; layer++) {
                    const count = 4 + layer * 2;
                    for (let i = 0; i < count; i++) {
                        buildings.push({ x: i * (innerWidth / count) * 1.5, width: 50 + Math.random() * 60, height: 80 + layer * 40 + Math.random() * 50, layer, isMaiTree: true, color: layer === 0 ? '#1a0505' : layer === 1 ? '#2a0a0a' : '#3a1010' });
                    }
                }
                for (let i = 0; i < 60; i++) stars.push({ x: Math.random() * innerWidth, y: Math.random() * innerHeight * 0.7, size: 1 + Math.random() * 2, twinkle: Math.random() * Math.PI * 2, isFirework: true });
                const tetObjs = ['üèÆ', 'üßß', 'üéÜ', 'üå∏', '‚ú®', 'üéã', 'üêâ', 'üíÆ'];
                for (let i = 0; i < 16; i++) floatingObjs.push({ x: Math.random() * innerWidth * 2, y: 80 + Math.random() * (innerHeight - 250), type: tetObjs[Math.floor(Math.random() * tetObjs.length)], size: 20 + Math.random() * 28, speed: 0.6 + Math.random() * 1.4, wobble: Math.random() * Math.PI * 2 });
            }
        }

        function restartFlappyGame() {
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('flappy-instructions').style.display = 'block';
            resetFlappyGame();
        }

        function flappyJump() {
            if (!flappyStarted) { flappyStarted = true; flappyRunning = true; document.getElementById('flappy-instructions').style.display = 'none'; }
            if (flappyRunning) {
                const settings = getGameSettings();
                flappyBird.velocity = settings.jump;
            }
        }

        document.getElementById('flappy-game').onclick = e => { if (e.target.tagName !== 'BUTTON') flappyJump(); };

        let lastPipeX = 0, lastGapY = 0;
        let pipeCounter = 0, itemAlternator = true;
        let itemHistory = []; // Track last 4 items to prevent repeats

        function createPipe() {
            const settings = getGameSettings();
            const gap = settings.pipeGap;

            // Smart gap positioning - limit vertical change
            const minY = gap / 2 + 60;
            const maxY = innerHeight - gap / 2 - 60;
            let gapCenterY;

            if (lastGapY === 0) {
                gapCenterY = innerHeight / 2;
            } else {
                const maxChange = gap * 0.7;
                gapCenterY = lastGapY + (Math.random() - 0.5) * 2 * maxChange;
                gapCenterY = Math.max(minY, Math.min(maxY, gapCenterY));
            }
            lastGapY = gapCenterY;

            const topH = gapCenterY - gap / 2;

            // Moving pipes (level 5+): some pipes oscillate up/down
            const isMoving = currentLevel >= 5 && Math.random() < 0.3;
            const moveSpeed = 0.5 + Math.random() * 0.5;
            const moveRange = 30 + Math.random() * 30;

            // Spike obstacle in gap (level 7+): slows player on touch
            const hasSpike = currentLevel >= 7 && Math.random() < 0.25;
            const spikeY = hasSpike ? gapCenterY : 0;

            const pipe = {
                x: innerWidth,
                topHeight: topH,
                bottomY: gapCenterY + gap / 2,
                gapCenterY,
                passed: false,
                isMoving,
                moveSpeed,
                moveRange,
                moveOffset: 0,
                moveDir: 1,
                hasSpike,
                spikeY,
                spikeHit: false
            };
            flappyPipes.push(pipe);

            // Item spawn: reduced frequency ‚Äî spawn roughly every 6+ pipes
            pipeCounter++;
            const spawnThreshold = 6 + Math.floor(currentLevel / 6); // rarer items; slowly changes with level
            if (pipeCounter >= spawnThreshold) {
                pipeCounter = 0;

                // Progressive difficulty using spawn counter for exact ratio
                // Level 1-3: 3 good then 1 bad (75% good)
                // Level 4-6: 2 good then 1 bad (66% good)
                // Level 7-10: 1 good then 1 bad (50% good)
                // Level 11+: 1 good then 2 bad (33% good)
                itemAlternator++;
                let isGood;
                if (currentLevel <= 3) {
                    isGood = (itemAlternator % 4) !== 0; // 3 good, 1 bad
                } else if (currentLevel <= 6) {
                    isGood = (itemAlternator % 3) !== 0; // 2 good, 1 bad
                } else if (currentLevel <= 10) {
                    isGood = (itemAlternator % 2) !== 0; // 1 good, 1 bad
                } else {
                    isGood = (itemAlternator % 3) === 1; // 1 good, 2 bad
                }

                // Select item avoiding last 4 used items
                function selectWithNoRepeat(items) {
                    const available = items.filter(item => !itemHistory.includes(item.type));
                    const pool = available.length > 0 ? available : items;

                    const totalWeight = pool.reduce((sum, item) => sum + item.rarity, 0);
                    let random = Math.random() * totalWeight;
                    for (const item of pool) {
                        random -= item.rarity;
                        if (random <= 0) {
                            itemHistory.push(item.type);
                            if (itemHistory.length > 5) itemHistory.shift(); // Wait 5 items before repeat
                            return item;
                        }
                    }
                    return pool[0];
                }

                if (isGood) {
                    const powerup = selectWithNoRepeat(POWERUPS);
                    gameItems.push({
                        x: innerWidth + PIPE_WIDTH * 4, // Farther from pipe
                        y: gapCenterY + (Math.random() - 0.5) * gap * 0.25,
                        ...powerup, isGood: true, collected: false
                    });
                } else {
                    const obstacle = selectWithNoRepeat(OBSTACLES);
                    const atTop = Math.random() > 0.5;
                    const obstacleY = atTop ?
                        gapCenterY - gap * 0.35 - 15 - Math.random() * 30 :
                        gapCenterY + gap * 0.35 + 15 + Math.random() * 30;
                    gameItems.push({
                        x: innerWidth + PIPE_WIDTH * 4, // Farther from pipe
                        y: Math.max(50, Math.min(innerHeight - 50, obstacleY)),
                        ...obstacle, isGood: false, collected: false
                    });
                }
            }
        }

        function updateFlappy() {
            if (!flappyRunning) return;
            const settings = getGameSettings();
            // Simplified: only shield and heart items remain, no speed/size modifiers
            const speedMult = 1;
            flappyBird.velocity += settings.gravity * speedMult;
            flappyBird.y += flappyBird.velocity * speedMult;
            flappyBird.radius = flappyBird.baseRadius;
            bgScrollX += 2 * speedMult;

            const spawnDist = Math.max(280, settings.spawnRate);
            if (flappyPipes.length === 0 || flappyPipes[flappyPipes.length - 1].x < innerWidth - spawnDist) createPipe();

            for (let i = flappyPipes.length - 1; i >= 0; i--) {
                const p = flappyPipes[i];
                p.x -= settings.pipeSpeed * speedMult;

                // Moving pipes oscillate up/down
                if (p.isMoving) {
                    p.moveOffset += p.moveSpeed * p.moveDir;
                    if (Math.abs(p.moveOffset) > p.moveRange) {
                        p.moveDir *= -1;
                    }
                }

                // Check spike collision
                if (p.hasSpike && !p.spikeHit) {
                    const spikeX = p.x + PIPE_WIDTH / 2;
                    const spikeY = p.gapCenterY + (p.moveOffset || 0);
                    const dx = flappyBird.x - spikeX;
                    const dy = flappyBird.y - spikeY;
                    if (Math.sqrt(dx * dx + dy * dy) < flappyBird.radius + 25) {
                        p.spikeHit = true;
                        if (activeEffects.shield) {
                            activeEffects.shield = false;
                            showItemPopup('üõ°Ô∏è Ch·∫∑n!', '#00ff7f', spikeX, spikeY);
                            updateEffectsUI();
                        } else {
                            // Slow effect - reduce velocity
                            activeEffects.slow = Date.now() + 2000;
                            flappyBird.velocity *= 0.5;
                            showItemPopup('üîª Ch·∫≠m!', '#ff6600', spikeX, spikeY);
                        }
                    }
                }

                if (!p.passed && p.x + PIPE_WIDTH < flappyBird.x) {
                    p.passed = true;
                    flappyScore += 1;
                    document.getElementById('flappy-score').textContent = flappyScore;
                    updateLevel();
                }
                if (p.x < -PIPE_WIDTH) flappyPipes.splice(i, 1);
            }

            // Update items
            for (let i = gameItems.length - 1; i >= 0; i--) {
                gameItems[i].x -= settings.pipeSpeed * speedMult;
                if (gameItems[i].x < -50) { gameItems.splice(i, 1); continue; }
                if (gameItems[i].collected) continue;

                // Check collision with item
                const dx = flappyBird.x - gameItems[i].x;
                const dy = flappyBird.y - gameItems[i].y;
                if (Math.sqrt(dx * dx + dy * dy) < flappyBird.radius + 20) {
                    collectItem(gameItems[i]);
                    gameItems[i].collected = true;
                }
            }

            // Spawn shurikens (level 7+) - flying projectiles
            if (currentLevel >= 7 && Math.random() < 0.008) { // Low spawn rate
                shurikens.push({
                    x: innerWidth + 50,
                    y: 80 + Math.random() * (innerHeight - 160),
                    speed: 4 + Math.random() * 3,
                    hit: false
                });
            }

            // Update shurikens
            for (let i = shurikens.length - 1; i >= 0; i--) {
                const s = shurikens[i];
                s.x -= s.speed;
                if (s.x < -50) { shurikens.splice(i, 1); continue; }
                if (s.hit) continue;

                // Check collision with player
                const dx = flappyBird.x - s.x;
                const dy = flappyBird.y - s.y;
                if (Math.sqrt(dx * dx + dy * dy) < flappyBird.radius + 18) {
                    s.hit = true;
                    if (activeEffects.shield) {
                        activeEffects.shield = false;
                        showItemPopup('üõ°Ô∏è Ch·∫∑n!', '#00ff7f', s.x, s.y);
                        updateEffectsUI();
                    } else {
                        // Slow effect - apply immediately
                        flappyBird.velocity = Math.min(flappyBird.velocity, 1);
                        showItemPopup('üîª Ch·∫≠m!', '#ff6600', s.x, s.y);
                    }
                }
            }

            // Update effects
            updateEffects();
            checkCollision();
        }

        // Floating popup texts
        let floatingTexts = [];

        function showItemPopup(text, color, x, y) {
            floatingTexts.push({ text, color, x, y, opacity: 1, birth: Date.now() });
        }

        function collectItem(item) {
            const descriptions = {
                shield: 'üõ°Ô∏è KHI√äN B·∫¢O V·ªÜ!',
                heart: 'üíñ +1 M·∫†NG!',
                bomb: 'üí£ BOM!'
            };

            showItemPopup(descriptions[item.type] || item.type, item.color, item.x, item.y);

            if (item.isGood) {
                if (item.type === 'shield') {
                    activeEffects.shield = true;
                } else if (item.type === 'heart') {
                    playerLives++;
                    updateLivesUI();
                }
                updateEffectsUI();
            } else {
                // Bad items - shield blocks bomb
                if (activeEffects.shield) {
                    activeEffects.shield = false;
                    showItemPopup('üõ°Ô∏è Ch·∫∑n!', '#00ff7f', item.x, item.y);
                    updateEffectsUI();
                    return;
                }

                if (item.type === 'bomb') {
                    if (playerLives > 1) {
                        playerLives--;
                        updateLivesUI();
                        showItemPopup('üíî M·∫§T 1 M·∫†NG!', '#ff4444', item.x, item.y);
                    } else {
                        gameOver();
                    }
                }
            }
        }

        function updateLivesUI() {
            const livesEl = document.getElementById('player-lives');
            if (livesEl) livesEl.textContent = 'üíñ'.repeat(playerLives);
        }

        function updateEffects() {
            // No timed global effects in the simplified mode; shield is handled when consumed.
            return;
        }

        function updateEffectsUI() {
            const container = document.getElementById('active-effects');
            container.innerHTML = '';
            if (activeEffects.shield) {
                container.innerHTML += '<div class="effect-badge" style="border-color:#00ff7f;color:#00ff7f;">üõ°Ô∏è Shield</div>';
            }
        }

        function checkCollision() {
            // Check ground/ceiling collision
            if (flappyBird.y - flappyBird.radius < 0 || flappyBird.y + flappyBird.radius > innerHeight) {
                if (activeEffects.shield) {
                    activeEffects.shield = false;
                    updateEffectsUI();
                    showItemPopup('üõ°Ô∏è SHIELD CH·∫∂N!', '#00ff7f', flappyBird.x, flappyBird.y);
                    flappyBird.y = Math.max(flappyBird.radius + 10, Math.min(innerHeight - flappyBird.radius - 10, flappyBird.y));
                    flappyBird.velocity = 0;
                    return;
                }
                if (playerLives > 1) {
                    playerLives--;
                    updateLivesUI();
                    showItemPopup('üíî M·∫§T 1 M·∫†NG!', '#ff4444', flappyBird.x, flappyBird.y);
                    flappyBird.y = innerHeight / 2;
                    flappyBird.velocity = 0;
                    return;
                }
                gameOver();
                return;
            }

            // Check pipe collision
            for (let p of flappyPipes) {
                if (flappyBird.x + flappyBird.radius > p.x && flappyBird.x - flappyBird.radius < p.x + PIPE_WIDTH) {
                    if (flappyBird.y - flappyBird.radius < p.topHeight || flappyBird.y + flappyBird.radius > p.bottomY) {
                        if (activeEffects.shield) {
                            activeEffects.shield = false;
                            updateEffectsUI();
                            showItemPopup('üõ°Ô∏è SHIELD CH·∫∂N!', '#00ff7f', flappyBird.x, flappyBird.y);
                            return;
                        }
                        if (playerLives > 1) {
                            playerLives--;
                            updateLivesUI();
                            showItemPopup('üíî M·∫§T 1 M·∫†NG!', '#ff4444', flappyBird.x, flappyBird.y);
                            // Reset position to just past this pipe
                            flappyBird.x = p.x + PIPE_WIDTH + flappyBird.radius + 10;
                            flappyBird.y = p.gapCenterY;
                            flappyBird.velocity = 0;
                            return;
                        }
                        gameOver();
                        return;
                    }
                }
            }
        }

        function gameOver() {
            flappyRunning = false;
            if (flappyScore > flappyHighScore) { flappyHighScore = flappyScore; localStorage.setItem('flappyHS', flappyHighScore); }
            document.getElementById('final-score').textContent = flappyScore;
            document.getElementById('final-level').textContent = 'Level: ' + currentLevel;
            document.getElementById('high-score').textContent = 'High Score: ' + flappyHighScore;
            document.getElementById('game-over-screen').style.display = 'block';
            saveScore(flappyScore, currentLevel);
            updatePlayerNameDisplay();
        }

        function drawFlappy() {
            const ctx = flappyCtx, w = flappyCanvas.width, h = flappyCanvas.height;
            ctx.clearRect(0, 0, w, h);

            // Sky gradient - ALL THEMES use dark purple base for consistency
            const sky = ctx.createLinearGradient(0, 0, 0, h);
            if (currentTheme === 'city') {
                // Dark purple with pink glow
                sky.addColorStop(0, '#0a0018'); sky.addColorStop(0.4, '#1a0035'); sky.addColorStop(0.7, '#2d0050'); sky.addColorStop(1, '#3a0060');
            } else if (currentTheme === 'forest') {
                // Dark purple with green hints - mystical forest
                sky.addColorStop(0, '#0a0818'); sky.addColorStop(0.4, '#12102a'); sky.addColorStop(0.7, '#1a1538'); sky.addColorStop(1, '#221a45');
            } else if (currentTheme === 'sakura') {
                // Dark magenta-purple cherry blossom
                sky.addColorStop(0, '#100818'); sky.addColorStop(0.4, '#180d20'); sky.addColorStop(0.7, '#201228'); sky.addColorStop(1, '#281535');
            } else if (currentTheme === 'ocean') {
                // Dark blue-purple underwater
                sky.addColorStop(0, '#050515'); sky.addColorStop(0.4, '#0a1025'); sky.addColorStop(0.7, '#101530'); sky.addColorStop(1, '#152040');
            } else if (currentTheme === 'space') {
                // Deep dark space
                sky.addColorStop(0, '#020008'); sky.addColorStop(0.4, '#080015'); sky.addColorStop(0.7, '#0c0020'); sky.addColorStop(1, '#12002a');
            } else if (currentTheme === 'tet') {
                // Dark red-crimson Vietnamese Tet
                sky.addColorStop(0, '#150808'); sky.addColorStop(0.4, '#1f0c0c'); sky.addColorStop(0.7, '#2a1010'); sky.addColorStop(1, '#351515');
            }
            ctx.fillStyle = sky;
            ctx.fillRect(0, 0, w, h);

            // Smooth theme transition fade effect - softer pink glow
            if (themeTransition > 0) {
                ctx.fillStyle = `rgba(255, 150, 200, ${themeTransition * 0.25})`;
                ctx.fillRect(0, 0, w, h);
                themeTransition = Math.max(0, themeTransition - 0.02);
            }

            // Stars with twinkle
            const time = Date.now() / 1000;
            stars.forEach(s => {
                const brightness = 0.5 + Math.sin(time * 3 + s.twinkle) * 0.5;
                ctx.beginPath();
                const sx = ((s.x - bgScrollX * 0.05) % (w + 50) + w + 50) % (w + 50);
                ctx.arc(sx, s.y, s.size, 0, Math.PI * 2);
                ctx.fillStyle = currentTheme === 'space' ? `rgba(255, 255, 255, ${brightness})` : `rgba(255, 200, 220, ${brightness * 0.7})`;
                ctx.fill();
            });

            // Clouds or Bubbles
            clouds.forEach(c => {
                const cx = ((c.x - bgScrollX * c.speed * 0.3) % (w + 200) + w + 200) % (w + 200) - 100;
                if (c.isBubble) {
                    // Ocean bubbles
                    ctx.beginPath();
                    ctx.arc(cx, (c.y - bgScrollX * 0.2) % h, c.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.arc(cx, c.y, c.size, 0, Math.PI * 2);
                    ctx.arc(cx + c.size * 0.6, c.y - c.size * 0.2, c.size * 0.7, 0, Math.PI * 2);
                    ctx.arc(cx - c.size * 0.5, c.y + c.size * 0.1, c.size * 0.6, 0, Math.PI * 2);
                    ctx.fillStyle = currentTheme === 'countryside' ? 'rgba(255, 255, 255, 0.8)' : 'rgba(80, 40, 100, 0.3)';
                    ctx.fill();
                }
            });

            // Draw theme elements (Buildings/Hills/Coral/Planets)
            if (currentTheme === 'space') {
                // Draw planets
                buildings.forEach(p => {
                    if (!p.isPlanet) return;
                    const px = ((p.x - bgScrollX * 0.1) % (w + 100) + w + 100) % (w + 100);
                    ctx.beginPath();
                    ctx.arc(px, p.y, p.width / 2, 0, Math.PI * 2);
                    const pGrad = ctx.createRadialGradient(px - p.width / 4, p.y - p.width / 4, 0, px, p.y, p.width / 2);
                    pGrad.addColorStop(0, '#ffffff40'); pGrad.addColorStop(0.3, p.color); pGrad.addColorStop(1, '#00000080');
                    ctx.fillStyle = pGrad;
                    ctx.fill();
                    // Ring for some planets
                    if (p.color === '#ffd700') {
                        ctx.beginPath(); ctx.ellipse(px, p.y, p.width * 0.8, p.width * 0.2, 0.3, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)'; ctx.lineWidth = 3; ctx.stroke();
                    }
                });
            } else {
                for (let layer = 0; layer < 3; layer++) {
                    const speedMult = 0.2 + layer * 0.3;
                    buildings.filter(b => b.layer === layer).forEach(b => {
                        const bx = ((b.x - bgScrollX * speedMult) % (w * 1.5) + w * 1.5) % (w * 1.5) - w * 0.25;
                        const by = h - b.height;

                        if (b.isHill) {
                            // Countryside hills
                            ctx.beginPath();
                            ctx.moveTo(bx - b.width / 2, h);
                            ctx.quadraticCurveTo(bx + b.width / 2, by - b.height * 0.3, bx + b.width * 1.5, h);
                            ctx.fillStyle = b.color;
                            ctx.fill();
                        } else if (b.isTree) {
                            // Forest pine trees
                            ctx.fillStyle = b.color;
                            // Trunk
                            ctx.fillRect(bx + b.width * 0.4, by + b.height * 0.6, b.width * 0.2, b.height * 0.4);
                            // Tree layers
                            for (let t = 0; t < 3; t++) {
                                ctx.beginPath();
                                const ty = by + t * b.height * 0.25;
                                const tw = b.width * (1 - t * 0.2);
                                ctx.moveTo(bx + b.width / 2, ty);
                                ctx.lineTo(bx + b.width / 2 - tw / 2, ty + b.height * 0.35);
                                ctx.lineTo(bx + b.width / 2 + tw / 2, ty + b.height * 0.35);
                                ctx.closePath();
                                ctx.fillStyle = `rgba(30, ${80 + layer * 30}, 40, ${0.6 + layer * 0.15})`;
                                ctx.fill();
                            }
                        } else if (b.isSakuraTree) {
                            // Sakura tree with pink blossoms
                            ctx.fillStyle = '#3a2020';
                            ctx.fillRect(bx + b.width * 0.4, by + b.height * 0.5, b.width * 0.2, b.height * 0.5);
                            // Pink blossom top
                            ctx.beginPath();
                            ctx.arc(bx + b.width / 2, by + b.height * 0.3, b.width * 0.5, 0, Math.PI * 2);
                            ctx.fillStyle = `rgba(255, ${150 + layer * 30}, 200, ${0.5 + layer * 0.15})`;
                            ctx.fill();
                        } else if (b.isMaiTree) {
                            // Mai/Dao tree with yellow/pink flowers
                            ctx.fillStyle = '#4a3020';
                            ctx.fillRect(bx + b.width * 0.35, by + b.height * 0.4, b.width * 0.3, b.height * 0.6);
                            // Yellow/pink flower blooms
                            const flowerColor = layer % 2 === 0 ? '#ffd700' : '#ff69b4';
                            for (let f = 0; f < 5; f++) {
                                const fx = bx + b.width * 0.2 + Math.random() * b.width * 0.6;
                                const fy = by + Math.random() * b.height * 0.5;
                                ctx.beginPath();
                                ctx.arc(fx, fy, 5 + Math.random() * 8, 0, Math.PI * 2);
                                ctx.fillStyle = flowerColor;
                                ctx.globalAlpha = 0.6 + layer * 0.15;
                                ctx.fill();
                                ctx.globalAlpha = 1;
                            }
                        } else if (b.isCoral) {
                            // Ocean coral
                            ctx.beginPath();
                            ctx.moveTo(bx, h);
                            for (let i = 0; i < 5; i++) {
                                ctx.lineTo(bx + b.width * (i / 5), by + Math.sin(i * 2 + time) * 10);
                                ctx.lineTo(bx + b.width * ((i + 0.5) / 5), by - 20 + Math.sin(i * 3 + time * 2) * 15);
                            }
                            ctx.lineTo(bx + b.width, h);
                            ctx.fillStyle = b.color;
                            ctx.fill();
                        } else {
                            // City buildings
                            ctx.fillStyle = b.color;
                            ctx.fillRect(bx, by, b.width, b.height);
                            ctx.strokeStyle = `rgba(255, 105, 180, ${0.1 + layer * 0.1})`;
                            ctx.lineWidth = 1;
                            ctx.strokeRect(bx, by, b.width, b.height);
                            // Windows
                            const winW = 6, winH = 10, winGap = 18;
                            for (let row = 0; row < Math.min(b.windows || 0, Math.floor((b.height - 20) / winGap)); row++) {
                                for (let col = 0; col < 3; col++) {
                                    const wx = bx + 8 + col * (b.width - 20) / 3;
                                    const wy = by + 12 + row * winGap;
                                    const lit = Math.sin(b.x + row * 5 + col * 7 + time) > 0.3;
                                    ctx.fillStyle = lit ? `rgba(255, 200, 100, ${0.4 + layer * 0.2})` : 'rgba(20, 10, 30, 0.8)';
                                    ctx.fillRect(wx, wy, winW, winH);
                                }
                            }
                            if (b.height > 180) {
                                ctx.strokeStyle = 'rgba(255, 105, 180, 0.4)'; ctx.lineWidth = 2;
                                ctx.beginPath(); ctx.moveTo(bx + b.width / 2, by); ctx.lineTo(bx + b.width / 2, by - 15); ctx.stroke();
                                if (Math.sin(time * 4) > 0) { ctx.beginPath(); ctx.arc(bx + b.width / 2, by - 15, 3, 0, Math.PI * 2); ctx.fillStyle = '#ff1493'; ctx.fill(); }
                            }
                        }
                    });
                }
            }

            // Floating objects
            floatingObjs.forEach(obj => {
                const ox = ((obj.x - bgScrollX * obj.speed * 0.5) % (w + 200) + w + 200) % (w + 200) - 100;
                const oy = obj.y + Math.sin(time * 2 + obj.wobble) * 15;
                ctx.font = obj.size + 'px serif';
                ctx.fillText(obj.type, ox, oy);
            });

            // Pipes
            flappyPipes.forEach(p => {
                // Apply move offset for moving pipes
                const offset = p.moveOffset || 0;
                const topH = p.topHeight + offset;
                const bottomY = p.bottomY + offset;

                const pGrad = ctx.createLinearGradient(p.x, 0, p.x + PIPE_WIDTH, 0);
                pGrad.addColorStop(0, '#8b008b'); pGrad.addColorStop(0.5, '#4b0082'); pGrad.addColorStop(1, '#8b008b');
                ctx.fillStyle = pGrad;
                ctx.fillRect(p.x, 0, PIPE_WIDTH, topH);
                ctx.fillRect(p.x, bottomY, PIPE_WIDTH, h - bottomY);

                // Moving pipe glow indicator
                if (p.isMoving) {
                    ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 4;
                } else {
                    ctx.strokeStyle = '#ff69b4'; ctx.lineWidth = 3;
                }
                ctx.strokeRect(p.x, 0, PIPE_WIDTH, topH);
                ctx.strokeRect(p.x, bottomY, PIPE_WIDTH, h - bottomY);

                // Pipe caps
                ctx.fillStyle = p.isMoving ? '#cc00cc' : '#9932cc';
                ctx.fillRect(p.x - 5, topH - 15, PIPE_WIDTH + 10, 15);
                ctx.fillRect(p.x - 5, bottomY, PIPE_WIDTH + 10, 15);

                // Draw spike in gap
                if (p.hasSpike) {
                    const spikeX = p.x + PIPE_WIDTH / 2;
                    const spikeY = p.gapCenterY + offset;
                    ctx.save();
                    ctx.translate(spikeX, spikeY);
                    ctx.rotate(time * 2);
                    // Draw spiky star
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const r = i % 2 === 0 ? 20 : 10;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fillStyle = p.spikeHit ? '#666' : '#ff4444';
                    ctx.fill();
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();
                }
            });

            // Draw Items (power-ups & obstacles) with SOFT CUTE effect
            gameItems.forEach(item => {
                if (item.collected) return;
                const bounce = Math.sin(time * 4 + item.x * 0.01) * 5;
                const ix = item.x, iy = item.y + bounce;

                // Soft pulsing effect
                const pulse = 0.95 + Math.sin(time * 4) * 0.08;
                const glowPulse = 0.6 + Math.sin(time * 3) * 0.4;

                // Soft pastel glow
                ctx.beginPath();
                ctx.arc(ix, iy, 22 + glowPulse * 6, 0, Math.PI * 2);
                const glowGrad = ctx.createRadialGradient(ix, iy, 0, ix, iy, 30);
                glowGrad.addColorStop(0, item.color + '88');
                glowGrad.addColorStop(0.6, item.color + '33');
                glowGrad.addColorStop(1, item.color + '00');
                ctx.fillStyle = glowGrad;
                ctx.fill();

                // Cute small star sparkles (3 only)
                for (let i = 0; i < 3; i++) {
                    const angle = (time * 1.5 + i * Math.PI * 2 / 3) % (Math.PI * 2);
                    const dist = 18 + Math.sin(time * 2 + i) * 4;
                    const sx = ix + Math.cos(angle) * dist;
                    const sy = iy + Math.sin(angle) * dist;
                    ctx.save();
                    ctx.translate(sx, sy);
                    ctx.rotate(time * 2 + i);
                    ctx.beginPath();
                    for (let j = 0; j < 4; j++) {
                        const a = j * Math.PI / 2;
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(a) * 3, Math.sin(a) * 3);
                    }
                    ctx.strokeStyle = item.isGood ? '#fff5cc' : '#ffcccc';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    ctx.restore();
                }

                // Icon with gentle scale
                ctx.save();
                ctx.translate(ix, iy);
                ctx.scale(pulse, pulse);
                ctx.font = '28px serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(item.icon, 0, 0);
                ctx.restore();
            });

            // Draw flying shurikens
            shurikens.forEach(s => {
                ctx.save();
                ctx.translate(s.x, s.y);
                ctx.rotate(time * 8); // Fast rotation
                // Draw 4-pointed star shuriken
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const r = i % 2 === 0 ? 18 : 8;
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fillStyle = s.hit ? '#555' : '#ff3333';
                ctx.fill();
                ctx.strokeStyle = s.hit ? '#333' : '#ff0000';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Center circle
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fillStyle = s.hit ? '#444' : '#660000';
                ctx.fill();
                ctx.restore();
            });

            // HEART WITH CUTE SMALL WINGS
            const x = flappyBird.x, y = flappyBird.y, s = flappyBird.radius * 1.2;
            const rot = Math.max(-0.4, Math.min(0.4, flappyBird.velocity * 0.04));
            const wingFlap = Math.sin(time * 20) * 0.3;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rot);

            // Trail particles (smaller)
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.arc(-12 - i * 8, Math.sin(time * 12 + i) * 3, (4 - i) * 1.5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 182, 193, ${(4 - i) / 10})`;
                ctx.fill();
            }

            // Left wing (smaller, cuter)
            ctx.save();
            ctx.rotate(wingFlap * 0.8);
            ctx.beginPath();
            ctx.moveTo(-s * 0.35, -s * 0.1);
            ctx.quadraticCurveTo(-s * 0.7, -s * 0.5, -s * 0.9, -s * 0.15);
            ctx.quadraticCurveTo(-s * 0.75, s * 0.1, -s * 0.35, s * 0.05);
            ctx.closePath();
            const wingGrad = ctx.createLinearGradient(-s * 0.9, 0, -s * 0.3, 0);
            wingGrad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            wingGrad.addColorStop(0.5, 'rgba(255, 182, 193, 0.8)');
            wingGrad.addColorStop(1, 'rgba(255, 105, 180, 0.5)');
            ctx.fillStyle = wingGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,182,193,0.6)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();

            // Right wing (smaller, cuter)
            ctx.save();
            ctx.rotate(-wingFlap * 0.8);
            ctx.beginPath();
            ctx.moveTo(s * 0.35, -s * 0.1);
            ctx.quadraticCurveTo(s * 0.7, -s * 0.5, s * 0.9, -s * 0.15);
            ctx.quadraticCurveTo(s * 0.75, s * 0.1, s * 0.35, s * 0.05);
            ctx.closePath();
            ctx.fillStyle = wingGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,182,193,0.6)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();

            // Heart body
            ctx.shadowColor = '#ff1493';
            ctx.shadowBlur = 25;
            ctx.beginPath();
            ctx.moveTo(0, -s * 0.25);
            ctx.bezierCurveTo(-s * 0.5, -s * 0.8, -s, -s * 0.25, 0, s * 0.6);
            ctx.bezierCurveTo(s, -s * 0.25, s * 0.5, -s * 0.8, 0, -s * 0.25);
            const hGrad = ctx.createRadialGradient(0, -s * 0.2, 0, 0, 0, s);
            hGrad.addColorStop(0, '#fff0f5'); hGrad.addColorStop(0.3, '#ffb6c1'); hGrad.addColorStop(0.6, '#ff69b4'); hGrad.addColorStop(1, '#c71585');
            ctx.fillStyle = hGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(199, 21, 133, 0.6)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Shine
            ctx.beginPath();
            ctx.arc(-s * 0.25, -s * 0.35, s * 0.12, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-s * 0.1, -s * 0.2, s * 0.06, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();

            ctx.restore();

            // Draw floating popup texts
            const now = Date.now();
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i];
                const age = now - ft.birth;
                ft.opacity = 1 - age / 1500;
                ft.y -= 1.5;

                if (ft.opacity <= 0 || age > 1500) {
                    floatingTexts.splice(i, 1);
                    continue;
                }

                ctx.save();
                ctx.font = 'bold 22px "Fira Code", monospace';
                ctx.textAlign = 'center';
                ctx.fillStyle = ft.color;
                ctx.globalAlpha = ft.opacity;
                ctx.shadowColor = ft.color;
                ctx.shadowBlur = 15;
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.restore();
            }
        }

        function flappyGameLoop() {
            if (state !== 'FLAPPY') return;
            updateFlappy();
            drawFlappy();
            flappyAnimId = requestAnimationFrame(flappyGameLoop);
        }
    </script>
</body>

</html>
